{
  "name": "Workflow Builder (Gemini) - Fixed",
  "nodes": [
    {
      "parameters": {
        "path": "workflow-builder",
        "formTitle": "n8n Workflow Builder (Gemini)",
        "formDescription": "Describe your workflow needs and receive a production-ready n8n workflow JSON",
        "formFields": {
          "values": [
            {
              "fieldLabel": "Client Brief",
              "fieldType": "textarea",
              "requiredField": true
            },
            {
              "fieldLabel": "Your Email",
              "fieldType": "email",
              "requiredField": true
            }
          ]
        },
        "responseMode": "onReceived"
      },
      "id": "form-trigger",
      "name": "Form Trigger",
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2,
      "position": [250, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract form data\nconst formData = items[0].json;\nconst clientBrief = formData['Client Brief'] || '';\nconst clientEmail = formData['Your Email'] || '';\n\n// Build system prompt using template literal (safe for special chars)\nconst systemPrompt = `You are a requirements analyst. Extract and structure the key requirements from this client brief. \n\nOutput a clear list of:\n1. Primary goal\n2. Data sources needed\n3. Processing steps\n4. Output destinations\n5. Error handling needs\n6. Any specific constraints\n\nClient Brief:\n${clientBrief}`;\n\n// Build Gemini request object\nconst geminiRequest = {\n  contents: [\n    {\n      parts: [\n        {\n          text: systemPrompt\n        }\n      ]\n    }\n  ]\n};\n\nreturn [{\n  json: {\n    geminiRequest: geminiRequest,\n    clientBrief: clientBrief,\n    clientEmail: clientEmail\n  }\n}];"
      },
      "id": "build-brief-parser-request",
      "name": "Build Brief Parser Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [500, 300]
    },
    {
      "parameters": {
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyDwHRrv4WHwHDDvK0KzdfpTfm1pnMBbNPk",
        "authentication": "none",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{ JSON.stringify($json.geminiRequest) }}",
        "options": {
          "continueOnFail": true
        }
      },
      "id": "brief-parser",
      "name": "Brief Parser",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [750, 300]
    },
    {
      "parameters": {
        "jsCode": "// Get previous node outputs\nconst briefParserOutput = items[0].json;\nconst contextData = $('Build Brief Parser Request').first().json;\n\n// Extract Gemini response\nlet parsedRequirements = '';\nif (briefParserOutput.candidates && briefParserOutput.candidates[0]) {\n  parsedRequirements = briefParserOutput.candidates[0].content.parts[0].text;\n}\n\n// Build architect system prompt\nconst systemPrompt = `You are an expert n8n workflow architect with 10+ years of automation experience.\n\nGiven a project brief, you:\n1. Break down requirements into discrete tasks\n2. Design node-by-node workflow structure\n3. Define data transformations at each stage\n4. Identify error handling paths\n5. Output production-ready roadmap\n\nYour Output Format (ALWAYS JSON):\n{\n  \"project_summary\": \"what the brief is asking for\",\n  \"nodes_required\": [\n    {\n      \"name\": \"NodeName\",\n      \"type\": \"n8n-nodes-base.webhook\",\n      \"typeVersion\": 2,\n      \"position\": [250, 300],\n      \"parameters\": {}\n    }\n  ],\n  \"connection_paths\": [],\n  \"data_schema\": {}\n}\n\nConstraints:\n- Keep to 3-7 nodes for MVP\n- Focus on data flow\n- Assume n8n Cloud deployment\n\nOriginal brief:\n${contextData.clientBrief}\n\nParsed requirements:\n${parsedRequirements}`;\n\nconst geminiRequest = {\n  contents: [\n    {\n      parts: [\n        {\n          text: systemPrompt\n        }\n      ]\n    }\n  ]\n};\n\nreturn [{\n  json: {\n    geminiRequest: geminiRequest,\n    clientBrief: contextData.clientBrief,\n    clientEmail: contextData.clientEmail,\n    parsedRequirements: parsedRequirements\n  }\n}];"
      },
      "id": "build-architect-request",
      "name": "Build Architect Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 300]
    },
    {
      "parameters": {
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyDwHRrv4WHwHDDvK0KzdfpTfm1pnMBbNPk",
        "authentication": "none",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{ JSON.stringify($json.geminiRequest) }}",
        "options": {
          "continueOnFail": true
        }
      },
      "id": "architect-agent",
      "name": "Architect Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "jsCode": "// Get architect output\nconst architectOutput = items[0].json;\nconst contextData = $('Build Architect Request').first().json;\n\n// Check for errors from Gemini API\nif (architectOutput.error) {\n  return [{\n    json: {\n      error: true,\n      message: \"Architect Agent failed: \" + (architectOutput.error.message || 'Unknown error'),\n      stage: \"architect\",\n      clientEmail: contextData.clientEmail\n    }\n  }];\n}\n\n// Extract architect specification\nlet architectSpec;\ntry {\n  const geminiResponse = architectOutput.candidates?.[0]?.content?.parts?.[0]?.text;\n  if (!geminiResponse) {\n    throw new Error('No response from Gemini');\n  }\n  \n  // Parse JSON response\n  let jsonText = geminiResponse;\n  if (jsonText.includes('```json')) {\n    jsonText = jsonText.split('```json')[1].split('```')[0].trim();\n  }\n  architectSpec = JSON.parse(jsonText);\n} catch (e) {\n  return [{\n    json: {\n      error: true,\n      message: \"Failed to parse architect output: \" + e.message,\n      stage: \"architect-parse\",\n      clientEmail: contextData.clientEmail\n    }\n  }];\n}\n\n// Key lessons from production workflows\nconst lessonsLearned = `\nCritical n8n Patterns:\n1. Use contentType: 'raw' for HTTP Request nodes with expressions (NOT 'json')\n2. Code nodes must return [{json: {...}}] format\n3. Gmail OAuth2 for emails (not SMTP on n8n Cloud)\n4. continueOnFail: true for error handling\n5. main[0] = success path, main[1] = error path\n6. Form data accessed at root: $json['fieldName']\n7. Always include position coordinates for nodes\n8. Connections use node names, not IDs\n9. Each node needs unique ID\n10. Gemini API uses query parameter for API key authentication\n11. Gemini response format: candidates[0].content.parts[0].text\n12. NEVER use string concatenation in JSON.stringify()\n13. Use Code nodes before HTTP requests to build request objects with template literals\n`;\n\nreturn [{\n  json: {\n    architectSpec: architectSpec,\n    lessonsLearned: lessonsLearned,\n    clientBrief: contextData.clientBrief,\n    clientEmail: contextData.clientEmail,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "prepare-synthesis-context",
      "name": "Prepare Synthesis Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1500, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.error }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-for-errors",
      "name": "Check for Errors",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1750, 300]
    },
    {
      "parameters": {
        "jsCode": "// Get context from previous node\nconst contextData = items[0].json;\n\n// Build synthesis prompt\nconst systemPrompt = `You are Claude CC Agent, a specialized code reasoning AI for n8n workflows.\n\nResponsibilities:\n- Convert architect specifications to production-ready n8n workflow JSON\n- Apply critical patterns from lessons learned\n- Validate all JSON before output\n- Include node connections, error handling, and proper credentials\n\nOutput ONLY valid n8n workflow JSON that can be directly imported.\n\nCritical Requirements:\n- Use contentType: 'raw' for HTTP Request nodes\n- Code nodes return [{json: {...}}] format\n- Use Gmail OAuth2 for emails\n- Include continueOnFail: true on HTTP nodes\n- Proper node IDs and connections\n- Position coordinates for visual layout\n\nConvert this architect specification to production n8n workflow JSON:\n\nArchitect Spec:\n${JSON.stringify(contextData.architectSpec, null, 2)}\n\nApply these critical patterns:\n${contextData.lessonsLearned}\n\nOutput complete workflow JSON with name, nodes, connections, settings.`;\n\nconst geminiRequest = {\n  contents: [\n    {\n      parts: [\n        {\n          text: systemPrompt\n        }\n      ]\n    }\n  ]\n};\n\nreturn [{\n  json: {\n    geminiRequest: geminiRequest,\n    contextData: contextData\n  }\n}];"
      },
      "id": "build-synthesis-request",
      "name": "Build Synthesis Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 250]
    },
    {
      "parameters": {
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyDwHRrv4WHwHDDvK0KzdfpTfm1pnMBbNPk",
        "authentication": "none",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{ JSON.stringify($json.geminiRequest) }}",
        "options": {
          "continueOnFail": true
        }
      },
      "id": "synthesis-agent",
      "name": "Synthesis Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2250, 250]
    },
    {
      "parameters": {
        "jsCode": "// Extract the workflow JSON from Gemini's response\nconst geminiOutput = items[0].json;\nconst contextData = $('Build Synthesis Request').first().json.contextData;\n\n// Check for API errors\nif (geminiOutput.error) {\n  return [{\n    json: {\n      error: true,\n      message: \"Synthesis Agent failed: \" + (geminiOutput.error.message || 'Unknown error'),\n      stage: \"synthesis\",\n      clientEmail: contextData.clientEmail\n    }\n  }];\n}\n\nlet workflowJson;\ntry {\n  // Extract the text content from Gemini response\n  const responseText = geminiOutput.candidates?.[0]?.content?.parts?.[0]?.text;\n  \n  if (!responseText) {\n    throw new Error('No response from Gemini');\n  }\n  \n  // Clean up the response if it has markdown code blocks\n  let jsonText = responseText;\n  if (jsonText.includes('```json')) {\n    jsonText = jsonText.split('```json')[1].split('```')[0].trim();\n  } else if (jsonText.includes('```')) {\n    jsonText = jsonText.split('```')[1].split('```')[0].trim();\n  }\n  \n  // Parse the JSON\n  workflowJson = JSON.parse(jsonText);\n  \n} catch (error) {\n  return [{\n    json: {\n      error: true,\n      message: \"Failed to parse workflow JSON: \" + error.message,\n      stage: \"json-parse\",\n      clientEmail: contextData.clientEmail\n    }\n  }];\n}\n\n// Return the workflow JSON and metadata\nreturn [{\n  json: {\n    workflowJson: workflowJson,\n    clientEmail: contextData.clientEmail,\n    clientBrief: contextData.clientBrief,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "format-final-output",
      "name": "Format Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2500, 250]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.error }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-final-output-errors",
      "name": "Check Final Output for Errors",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2750, 250]
    },
    {
      "parameters": {
        "operation": "sendMessage",
        "sendTo": "={{ $json.clientEmail }}",
        "subject": "Your n8n Workflow is Ready!",
        "message": "Hi!<br><br>Your custom n8n workflow has been generated successfully.<br><br><b>Original Request:</b><br>{{ $json.clientBrief }}<br><br><b>Generated Workflow JSON:</b><br><pre style=\"background: #f4f4f4; padding: 10px; border-radius: 5px; overflow-x: auto;\">{{ JSON.stringify($json.workflowJson, null, 2) }}</pre><br><br><b>How to use:</b><br>1. Copy the JSON above<br>2. Open n8n<br>3. Click 'Import from File' or paste directly<br>4. Configure any required credentials<br>5. Test and activate your workflow<br><br>Happy automating!<br>The n8n Workflow Builder",
        "options": {
          "appendAttribution": false
        }
      },
      "id": "send-workflow-email",
      "name": "Send Workflow Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [3000, 200],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth2",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Consolidate error information\nconst errorData = items[0].json;\n\nreturn [{\n  json: {\n    errorMessage: errorData.message || \"Unknown error occurred\",\n    errorStage: errorData.stage || \"unknown\",\n    clientEmail: errorData.clientEmail || \"no-email@provided.com\",\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 500]
    },
    {
      "parameters": {
        "operation": "sendMessage",
        "sendTo": "={{ $json.clientEmail }}",
        "subject": "Workflow Generation Failed - Error Report",
        "message": "Hi,<br><br>Unfortunately, we encountered an error while generating your workflow.<br><br><b>Error Details:</b><br>Stage: {{ $json.errorStage }}<br>Message: {{ $json.errorMessage }}<br>Time: {{ $json.timestamp }}<br><br><b>Common Solutions:</b><br>• Try simplifying your request<br>• Ensure your brief is clear and specific<br>• Avoid special characters or complex formatting<br>• Break down complex workflows into smaller parts<br><br><b>Need Help?</b><br>Reply to this email with your questions or try submitting a simpler version of your request.<br><br>The n8n Workflow Builder",
        "options": {
          "appendAttribution": false
        }
      },
      "id": "send-error-email",
      "name": "Send Error Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [2250, 500],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth2",
          "name": "Gmail OAuth2"
        }
      }
    }
  ],
  "connections": {
    "Form Trigger": {
      "main": [
        [
          {
            "node": "Build Brief Parser Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Brief Parser Request": {
      "main": [
        [
          {
            "node": "Brief Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Brief Parser": {
      "main": [
        [
          {
            "node": "Build Architect Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Architect Request": {
      "main": [
        [
          {
            "node": "Architect Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Architect Agent": {
      "main": [
        [
          {
            "node": "Prepare Synthesis Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Synthesis Context": {
      "main": [
        [
          {
            "node": "Check for Errors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Errors": {
      "main": [
        [
          {
            "node": "Build Synthesis Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Synthesis Request": {
      "main": [
        [
          {
            "node": "Synthesis Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Synthesis Agent": {
      "main": [
        [
          {
            "node": "Format Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Final Output": {
      "main": [
        [
          {
            "node": "Check Final Output for Errors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Final Output for Errors": {
      "main": [
        [
          {
            "node": "Send Workflow Email",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Send Error Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "workflow-builder-gemini-v2",
  "id": "workflow-builder-gemini-v2",
  "tags": [
    {
      "id": "meta",
      "name": "Meta"
    },
    {
      "id": "ai",
      "name": "AI"
    },
    {
      "id": "gemini",
      "name": "Gemini"
    }
  ]
}