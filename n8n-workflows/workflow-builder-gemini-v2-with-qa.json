{
  "name": "n8n Workflow Builder (Gemini) - with QA Validator",
  "nodes": [
    {
      "parameters": {
        "path": "workflow-builder",
        "formTitle": "n8n Workflow Builder",
        "formDescription": "Describe your workflow needs and receive a production-ready n8n workflow JSON",
        "formFields": {
          "values": [
            {
              "fieldLabel": "Client Brief",
              "fieldType": "textarea",
              "requiredField": true,
              "placeholder": "Describe what you want your workflow to do..."
            },
            {
              "fieldLabel": "Your Email",
              "fieldType": "email",
              "requiredField": true,
              "placeholder": "your@email.com"
            }
          ]
        },
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "form-trigger",
      "name": "Form Trigger",
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2,
      "position": [250, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyDwHRrv4WHwHDDvK0KzdfpTfm1pnMBbNPk",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{ JSON.stringify({\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are a requirements analyst. Extract and structure the key requirements from this client brief. Output a clear list of:\\n1. Primary goal\\n2. Data sources needed\\n3. Processing steps\\n4. Output destinations\\n5. Error handling needs\\n6. Any specific constraints\\n\\nClient Brief:\\n\" + $json['Client Brief']\n    }]\n  }]\n}) }}",
        "options": {
          "response": {
            "response": {
              "fullResponse": false,
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "brief-parser",
      "name": "Brief Parser",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [500, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyDwHRrv4WHwHDDvK0KzdfpTfm1pnMBbNPk",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{ JSON.stringify({\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are an expert n8n workflow architect with 10+ years of automation experience.\\n\\nGiven a project brief, you:\\n1. Break down requirements into discrete tasks\\n2. Design node-by-node workflow structure\\n3. Define data transformations at each stage\\n4. Identify error handling paths\\n5. Output production-ready roadmap\\n\\nYour Output Format (ALWAYS JSON):\\n{\\n  \\\"project_summary\\\": \\\"what the brief is asking for\\\",\\n  \\\"nodes_required\\\": [\\n    {\\n      \\\"name\\\": \\\"NodeName\\\",\\n      \\\"type\\\": \\\"n8n-nodes-base.webhook\\\",\\n      \\\"typeVersion\\\": 2,\\n      \\\"position\\\": [250, 300],\\n      \\\"parameters\\\": {}\\n    }\\n  ],\\n  \\\"connection_paths\\\": [],\\n  \\\"data_schema\\\": {}\\n}\\n\\nConstraints:\\n- Keep to 3-7 nodes for MVP\\n- Focus on data flow\\n- Assume n8n Cloud deployment\\n\\nOriginal brief: \" + $json['Client Brief'] + \"\\n\\nParsed requirements:\\n\" + JSON.stringify($json.candidates[0].content.parts[0].text)\n    }]\n  }]\n}) }}",
        "options": {
          "response": {
            "response": {
              "fullResponse": false,
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "architect-agent",
      "name": "Architect Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [750, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Prepare context for synthesis agent\nconst architectOutput = items[0].json;\nconst formData = $('Form Trigger').first().json;\n\n// Check for errors from previous nodes\nif (architectOutput.error) {\n  return [{\n    json: {\n      error: true,\n      message: \"Architect Agent failed: \" + (architectOutput.error.message || 'Unknown error'),\n      stage: \"architect\",\n      clientEmail: formData['Your Email']\n    }\n  }];\n}\n\nlet architectSpec;\ntry {\n  // Parse the architect's response from Gemini format\n  const geminiResponse = architectOutput.candidates?.[0]?.content?.parts?.[0]?.text;\n  if (!geminiResponse) {\n    throw new Error('No response from Gemini');\n  }\n  architectSpec = typeof geminiResponse === 'string' ? JSON.parse(geminiResponse) : geminiResponse;\n} catch (e) {\n  return [{\n    json: {\n      error: true,\n      message: \"Failed to parse architect output: \" + e.message,\n      stage: \"architect-parse\",\n      clientEmail: formData['Your Email']\n    }\n  }];\n}\n\n// Key lessons from production workflows\nconst lessonsLearned = `\nCritical n8n Patterns:\n1. Use contentType: 'raw' for HTTP Request nodes with expressions (NOT 'json')\n2. Code nodes must return [{json: {...}}] format\n3. Gmail OAuth2 for emails (not SMTP on n8n Cloud)\n4. continueOnFail: true for error handling\n5. main[0] = success path, main[1] = error path\n6. Use predefinedCredentialType for API auth\n7. Form data accessed at root: $json['fieldName']\n8. Always include position coordinates for nodes\n9. Connections use node names, not IDs\n10. Each node needs unique ID\n11. Gemini API uses query parameter for API key authentication\n12. Gemini response format: candidates[0].content.parts[0].text\n`;\n\n// Prepare synthesis context\nreturn [{\n  json: {\n    architectSpec: architectSpec,\n    lessonsLearned: lessonsLearned,\n    clientBrief: formData['Client Brief'],\n    clientEmail: formData['Your Email'],\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "prepare-context",
      "name": "Prepare Synthesis Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyDwHRrv4WHwHDDvK0KzdfpTfm1pnMBbNPk",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{ JSON.stringify({\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are Claude CC Agent, a specialized code reasoning AI for n8n workflows.\\n\\nResponsibilities:\\n- Convert architect specifications to production-ready n8n workflow JSON\\n- Apply critical patterns from lessons learned\\n- Validate all JSON before output\\n- Include node connections, error handling, and proper credentials\\n\\nOutput ONLY valid n8n workflow JSON that can be directly imported.\\n\\nCritical Requirements:\\n- Use contentType: 'raw' for HTTP Request nodes\\n- Code nodes return [{json: {...}}] format\\n- Use Gmail OAuth2 for emails\\n- Include continueOnFail: true on HTTP nodes\\n- Proper node IDs and connections\\n- Position coordinates for visual layout\\n\\nConvert this architect specification to production n8n workflow JSON:\\n\\nArchitect Spec:\\n\" + JSON.stringify($json.architectSpec, null, 2) + \"\\n\\nApply these critical patterns:\\n\" + $json.lessonsLearned + \"\\n\\nOutput complete workflow JSON with name, nodes, connections, settings.\"\n    }]\n  }]\n}) }}",
        "options": {
          "response": {
            "response": {
              "fullResponse": false,
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "synthesis-agent",
      "name": "Synthesis Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1250, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Format the final workflow for QA validation and email delivery\nconst synthesisOutput = items[0].json;\nconst contextData = $('Prepare Synthesis Context').first().json;\n\n// Check for synthesis errors\nif (synthesisOutput.error) {\n  return [{\n    json: {\n      error: true,\n      message: \"Synthesis failed: \" + (synthesisOutput.error.message || 'Unknown error'),\n      stage: \"synthesis\",\n      clientEmail: contextData.clientEmail\n    }\n  }];\n}\n\nlet workflowJson;\ntry {\n  // Extract the workflow JSON from Gemini response\n  const geminiResponse = synthesisOutput.candidates?.[0]?.content?.parts?.[0]?.text;\n  if (!geminiResponse) {\n    throw new Error('No response from Gemini');\n  }\n  \n  // Try to extract JSON from the response (Gemini sometimes adds markdown)\n  let jsonText = geminiResponse;\n  if (jsonText.includes('```json')) {\n    jsonText = jsonText.split('```json')[1].split('```')[0].trim();\n  } else if (jsonText.includes('```')) {\n    jsonText = jsonText.split('```')[1].split('```')[0].trim();\n  }\n  \n  workflowJson = JSON.parse(jsonText);\n  \n  // Ensure it has proper structure\n  if (!workflowJson.nodes || !workflowJson.connections) {\n    throw new Error('Invalid workflow structure - missing nodes or connections');\n  }\n} catch (e) {\n  return [{\n    json: {\n      error: true,\n      message: \"Failed to parse synthesis output: \" + e.message,\n      stage: \"synthesis-parse\",\n      clientEmail: contextData.clientEmail,\n      rawResponse: synthesisOutput.candidates?.[0]?.content?.parts?.[0]?.text || 'No response'\n    }\n  }];\n}\n\n// Create initial workflow summary (before QA validation)\nconst workflowSummary = `\n<h3>Generated Workflow</h3>\n<p><strong>Name:</strong> ${workflowJson.name || 'Custom Workflow'}</p>\n<p><strong>Nodes:</strong> ${workflowJson.nodes?.length || 0} operations</p>\n<p><strong>Generated:</strong> ${contextData.timestamp}</p>\n<p><strong>Status:</strong> Pending QA Validation...</p>\n`;\n\nreturn [{\n  json: {\n    success: true,\n    clientEmail: contextData.clientEmail,\n    clientBrief: contextData.clientBrief,\n    workflowJson: workflowJson,\n    workflowSummary: workflowSummary,\n    timestamp: contextData.timestamp,\n    qaValidationPending: true\n  }\n}];"
      },
      "id": "format-output",
      "name": "Format Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1500, 300]
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Load Knowledge Base for QA Validation\n// Reads all 4 knowledge base JSON files\n\ntry {\n  // In production, this would load from files\n  // For now, we'll prepare the data structure\n  // The QA Validator will use this context\n  \n  const previousData = items[0].json;\n  \n  // Structure for QA Validator input\n  return [{\n    json: {\n      ...previousData,\n      knowledgeBaseReady: true,\n      qaValidationStarting: true,\n      kbStats: {\n        patterns: 50,\n        nodes: 25,\n        validationRules: 30,\n        bestPractices: 50\n      }\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      error: true,\n      message: \"Failed to load knowledge base: \" + e.message,\n      stage: \"kb-load\"\n    }\n  }];\n}"
      },
      "id": "load-kb",
      "name": "Load Knowledge Base",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1700, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=AIzaSyDwHRrv4WHwHDDvK0KzdfpTfm1pnMBbNPk",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{ JSON.stringify({\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": \"You are an n8n Workflow QA Validator.\\n\\nYour job is to validate the generated n8n workflow JSON for correctness, completeness, and best practices.\\n\\nVALIDATION RULES TO CHECK:\\n1. STRUCTURAL: All node IDs unique, positions present, connections valid\\n2. CONFIGURATION: Required fields present, typeVersions correct\\n3. PATTERNS: contentType raw for expressions, code returns array, etc\\n4. SECURITY: No hardcoded API keys, credentials configured\\n5. BEST PRACTICES: Error handling, retry logic, input validation\\n6. REQUIREMENTS: Does workflow address original brief?\\n\\nCRITICAL PATTERNS (MUST APPLY):\\n- contentType: 'raw' for HTTP expressions (not 'json')\\n- Code nodes return [{json: {...}}] format\\n- Gmail OAuth2 (not SMTP on n8n Cloud)\\n- continueOnFail: true for error handling\\n- main[0] success, main[1] error paths\\n- Unique node IDs and position coordinates\\n- Connection node names (not IDs)\\n\\nORIGINAL USER BRIEF:\\n\" + $json.clientBrief + \"\\n\\nGENERATED WORKFLOW JSON:\\n\" + JSON.stringify($json.workflowJson, null, 2) + \"\\n\\nVALIDATE AND OUTPUT THIS JSON STRUCTURE:\\n{\\n  \\\"valid\\\": true/false,\\n  \\\"structureIssues\\\": [{\\\"node\\\": \\\"\\\", \\\"issue\\\": \\\"\\\"}],\\n  \\\"patternViolations\\\": [{\\\"pattern\\\": \\\"\\\", \\\"fix\\\": \\\"\\\"}],\\n  \\\"securityIssues\\\": [{\\\"issue\\\": \\\"\\\"}],\\n  \\\"missingRequirements\\\": [{\\\"requirement\\\": \\\"\\\"}],\\n  \\\"autoCorrections\\\": [{\\\"description\\\": \\\"\\\", \\\"change\\\": {}}],\\n  \\\"correctedWorkflow\\\": {...corrected workflow JSON...},\\n  \\\"confidence\\\": 0.95,\\n  \\\"summary\\\": \\\"Overall assessment\\\"\\n}\""
    }]
  }]
}) }}",
        "options": {
          "response": {
            "response": {
              "fullResponse": false,
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "qa-validator",
      "name": "QA Validator Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1900, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Format QA Validation Results\n// Merges QA results into final email output\n\nconst qaOutput = items[0].json;\n\ntry {\n  // Extract QA results from Gemini response\n  const geminiResponse = qaOutput.qa_validator_response?.candidates?.[0]?.content?.parts?.[0]?.text || \n                         qaOutput.candidates?.[0]?.content?.parts?.[0]?.text;\n  \n  if (!geminiResponse) {\n    // If QA failed, continue without it\n    return [{\n      json: {\n        ...qaOutput,\n        qaResults: null,\n        qaValidationFailed: true,\n        qaHtml: '<p style=\"color: #dc2626;\">⚠️ QA validation could not complete. Workflow may have issues.</p>'\n      }\n    }];\n  }\n\n  let qaResults;\n  try {\n    qaResults = JSON.parse(geminiResponse);\n  } catch (e) {\n    // Try to extract JSON from markdown\n    let jsonText = geminiResponse;\n    if (jsonText.includes('```json')) {\n      jsonText = jsonText.split('```json')[1].split('```')[0].trim();\n    } else if (jsonText.includes('```')) {\n      jsonText = jsonText.split('```')[1].split('```')[0].trim();\n    }\n    qaResults = JSON.parse(jsonText);\n  }\n\n  // If workflow has issues but can be auto-corrected, apply corrections\n  if (!qaResults.valid && qaResults.autoCorrections && qaResults.autoCorrections.length > 0 && qaResults.correctedWorkflow) {\n    qaResults.correctedWorkflow = qaResults.correctedWorkflow;\n    qaResults.workflowCorrected = true;\n  }\n\n  // Build QA HTML report\n  const qaHtml = `\n    <div style=\"background-color: #e0f2fe; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #0284c7;\">\n      <h3 style=\"margin-top: 0; color: #0284c7;\">✓ Quality Assurance Report</h3>\n      \n      <p><strong>Validation Status:</strong> ${qaResults.valid ? '✅ PASSED' : '⚠️ ISSUES FOUND'}</p>\n      <p><strong>Confidence Score:</strong> ${((qaResults.confidence || 0.95) * 100).toFixed(1)}%</p>\n      \n      ${qaResults.structureIssues && qaResults.structureIssues.length > 0 ? `\n        <div style=\"background-color: #fee2e2; padding: 10px; border-radius: 4px; margin: 10px 0;\">\n          <h4 style=\"margin: 0 0 10px 0; color: #dc2626;\">Structure Issues (${qaResults.structureIssues.length}):</h4>\n          <ul style=\"margin: 0; padding-left: 20px;\">\n            ${qaResults.structureIssues.map(i => `<li>${i.node}: ${i.issue}</li>`).join('')}\n          </ul>\n        </div>\n      ` : ''}\n      \n      ${qaResults.patternViolations && qaResults.patternViolations.length > 0 ? `\n        <div style=\"background-color: #fef3c7; padding: 10px; border-radius: 4px; margin: 10px 0;\">\n          <h4 style=\"margin: 0 0 10px 0; color: #d97706;\">Pattern Violations (${qaResults.patternViolations.length}):</h4>\n          <ul style=\"margin: 0; padding-left: 20px;\">\n            ${qaResults.patternViolations.map(p => `<li>${p.pattern}: ${p.fix}</li>`).join('')}\n          </ul>\n        </div>\n      ` : '<p style=\"color: #059669;\">✓ No pattern violations found</p>'}\n      \n      ${qaResults.securityIssues && qaResults.securityIssues.length > 0 ? `\n        <div style=\"background-color: #fee2e2; padding: 10px; border-radius: 4px; margin: 10px 0;\">\n          <h4 style=\"margin: 0 0 10px 0; color: #dc2626;\">⚠️ Security Issues (${qaResults.securityIssues.length}):</h4>\n          <ul style=\"margin: 0; padding-left: 20px;\">\n            ${qaResults.securityIssues.map(s => `<li>${s.issue}</li>`).join('')}\n          </ul>\n        </div>\n      ` : ''}\n      \n      ${qaResults.autoCorrections && qaResults.autoCorrections.length > 0 ? `\n        <div style=\"background-color: #d1fae5; padding: 10px; border-radius: 4px; margin: 10px 0;\">\n          <p><strong>✓ Applied Auto-Corrections: ${qaResults.autoCorrections.length}</strong></p>\n        </div>\n      ` : ''}\n      \n      <p style=\"margin: 10px 0 0 0; font-style: italic; color: #666;\">${qaResults.summary || 'QA validation complete'}</p>\n    </div>\n  `;\n\n  return [{\n    json: {\n      ...qaOutput,\n      qaResults: qaResults,\n      qaHtml: qaHtml,\n      qaValidationComplete: true,\n      finalWorkflowJson: qaResults.correctedWorkflow || qaOutput.workflowJson,\n      subject: qaResults.valid ? '✓ Your n8n Workflow is Ready (QA Passed)' : '⚠️ Your n8n Workflow (with QA Notes)'\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      ...qaOutput,\n      qaError: true,\n      qaErrorMessage: e.message,\n      qaHtml: '<p style=\"color: #dc2626;\">⚠️ QA validation encountered an error. Workflow included for your review.</p>'\n    }\n  }];\n}"
      },
      "id": "format-qa-results",
      "name": "Format QA Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2100, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-error",
              "leftValue": "={{ $json.error }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEqual"
              }
            }
          ],
          "combineOperation": "all"
        },
        "options": {}
      },
      "id": "check-errors",
      "name": "Check for Errors",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2300, 400]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "send",
        "sendTo": "={{ $json.clientEmail }}",
        "subject": "={{ $json.subject || '✓ Your n8n Workflow is Ready (Powered by Gemini)' }}",
        "messageType": "html",
        "message": "={{ `\n<h2 style=\"color: #2563eb;\">Your n8n Workflow is Ready!</h2>\n<p>Based on your brief, I've created a production-ready n8n workflow.</p>\n\n<div style=\"background-color: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;\">\n  <h3 style=\"margin-top: 0;\">Original Brief:</h3>\n  <p style=\"font-style: italic;\">\"` + $json.clientBrief + `\"</p>\n</div>\n\n<div style=\"background-color: #e0f2fe; padding: 15px; border-radius: 8px; margin: 20px 0;\">\n  <h3 style=\"margin-top: 0;\">Workflow Summary:</h3>\n  ` + $json.workflowSummary + `\n</div>\n\n` + ($json.qaHtml || '') + `\n\n<div style=\"background-color: #fef3c7; padding: 15px; border-radius: 8px; margin: 20px 0;\">\n  <h3 style=\"margin-top: 0;\">How to Import:</h3>\n  <ol>\n    <li>Copy the JSON below</li>\n    <li>Open your n8n instance</li>\n    <li>Go to Workflows → Import from File/URL</li>\n    <li>Paste the JSON and click Import</li>\n    <li>Configure any required credentials</li>\n    <li>Test with sample data</li>\n    <li>Activate and deploy</li>\n  </ol>\n</div>\n\n<hr style=\"margin: 30px 0;\">\n\n<h3>Workflow JSON:</h3>\n<pre style=\"background-color: #1e293b; color: #e2e8f0; padding: 20px; border-radius: 8px; overflow-x: auto; font-family: 'Courier New', monospace; font-size: 12px;\">\n` + JSON.stringify($json.finalWorkflowJson || $json.workflowJson, null, 2) + `\n</pre>\n\n<div style=\"margin-top: 30px; padding: 15px; background-color: #f0fdf4; border-left: 4px solid #22c55e;\">\n  <p style=\"margin: 0;\"><strong>✓ Workflow Generated Successfully</strong></p>\n  <p style=\"margin: 5px 0 0 0; color: #666;\">This workflow follows n8n best practices and production patterns.</p>\n</div>\n` }}",
        "options": {}
      },
      "id": "send-workflow",
      "name": "Send Workflow Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [2500, 200],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth2",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Comprehensive error handler for any stage failures\nconst errorData = items[0].json;\nconst formData = $('Form Trigger').first().json;\n\n// Determine error details\nconst stage = errorData.stage || 'unknown';\nconst message = errorData.message || errorData.error?.message || 'An unexpected error occurred';\nconst rawResponse = errorData.rawResponse || '';\n\nconst stageDescriptions = {\n  'architect': 'Workflow Architecture Design',\n  'architect-parse': 'Architecture Specification Parsing',\n  'synthesis': 'Workflow JSON Synthesis',\n  'synthesis-parse': 'Workflow JSON Parsing',\n  'brief-parser': 'Requirements Analysis',\n  'kb-load': 'Knowledge Base Loading',\n  'qa-validator': 'QA Validation',\n  'qa-format': 'QA Results Formatting',\n  'unknown': 'Workflow Generation'\n};\n\nconst errorHtml = `\n<h2 style=\"color: #dc2626;\">⚠ Workflow Generation Encountered an Issue</h2>\n<p>Unfortunately, we couldn't complete your workflow generation. Here are the details:</p>\n\n<div style=\"background-color: #fee2e2; padding: 15px; border-left: 4px solid #dc2626; margin: 20px 0;\">\n  <p><strong>Failed Stage:</strong> ${stageDescriptions[stage] || stage}</p>\n  <p><strong>Error Message:</strong> ${message}</p>\n</div>\n\n<div style=\"background-color: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;\">\n  <h3 style=\"margin-top: 0;\">Original Request:</h3>\n  <p style=\"font-style: italic;\">\"${formData['Client Brief']}\"</p>\n</div>\n\n${rawResponse ? `<div style=\"background-color: #fff3e0; padding: 15px; border-radius: 8px; margin: 20px 0;\">\n  <h3 style=\"margin-top: 0;\">Raw Response (for debugging):</h3>\n  <pre style=\"white-space: pre-wrap; font-size: 11px;\">${rawResponse}</pre>\n</div>` : ''}\n\n<div style=\"background-color: #fef3c7; padding: 15px; border-radius: 8px; margin: 20px 0;\">\n  <h3 style=\"margin-top: 0;\">What to Do Next:</h3>\n  <ul>\n    <li>Try simplifying your workflow description</li>\n    <li>Be more specific about the nodes and operations needed</li>\n    <li>Ensure your brief doesn't contain special characters that might cause parsing issues</li>\n    <li>If the problem persists, contact support with this error message</li>\n  </ul>\n</div>\n\n<p style=\"color: #666; font-size: 12px; margin-top: 30px;\">\n  <em>Error occurred at: ${new Date().toISOString()}</em>\n</p>\n`;\n\nreturn [{\n  json: {\n    error: true,\n    clientEmail: errorData.clientEmail || formData['Your Email'],\n    subject: '⚠ Workflow Generation Failed (Gemini)',\n    emailHtml: errorHtml,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2300, 700]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "send",
        "sendTo": "={{ $json.clientEmail }}",
        "subject": "={{ $json.subject }}",
        "messageType": "html",
        "message": "={{ $json.emailHtml }}",
        "options": {}
      },
      "id": "send-error",
      "name": "Send Error Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [2500, 700],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth2",
          "name": "Gmail OAuth2"
        }
      }
    }
  ],
  "connections": {
    "Form Trigger": {
      "main": [
        [
          {
            "node": "Brief Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Brief Parser": {
      "main": [
        [
          {
            "node": "Architect Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Architect Agent": {
      "main": [
        [
          {
            "node": "Prepare Synthesis Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Synthesis Context": {
      "main": [
        [
          {
            "node": "Check for Errors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Errors": {
      "main": [
        [
          {
            "node": "Synthesis Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Synthesis Agent": {
      "main": [
        [
          {
            "node": "Format Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Final Output": {
      "main": [
        [
          {
            "node": "Load Knowledge Base",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Knowledge Base": {
      "main": [
        [
          {
            "node": "QA Validator Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "QA Validator Agent": {
      "main": [
        [
          {
            "node": "Format QA Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format QA Results": {
      "main": [
        [
          {
            "node": "Check for Errors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Send Error Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "versionId": "workflow-builder-gemini-v2-qa",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "workflow-builder-gemini-v2"
  },
  "id": "workflow-builder-gemini-v2-qa",
  "tags": [
    {
      "name": "Meta",
      "createdAt": "2025-11-05T00:00:00.000Z"
    },
    {
      "name": "AI",
      "createdAt": "2025-11-05T00:00:00.000Z"
    },
    {
      "name": "Gemini",
      "createdAt": "2025-11-05T00:00:00.000Z"
    },
    {
      "name": "QA Validator",
      "createdAt": "2025-11-05T00:00:00.000Z"
    }
  ]
}
