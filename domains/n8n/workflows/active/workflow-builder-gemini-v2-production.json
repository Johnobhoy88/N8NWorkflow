{
  "name": "n8n Workflow Builder (Gemini) - Production Ready",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [{"mode": "everyMinute"}]
        },
        "filters": {
          "labelIds": ["INBOX"],
          "q": "is:unread subject:[WORKFLOW]"
        },
        "options": {
          "markAsRead": true
        }
      },
      "id": "email-trigger",
      "name": "Email Trigger",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1.1,
      "position": [250, 100],
      "credentials": {
        "gmailOAuth2": {
          "id": "existing",
          "name": "Gmail OAuth2"
        }
      },
      "notes": "Triggers on unread emails with [WORKFLOW] in subject. Polls every minute."
    },
    {
      "parameters": {
        "path": "workflow-builder",
        "formTitle": "n8n Workflow Builder",
        "formDescription": "Describe your workflow needs and receive a production-ready n8n workflow JSON",
        "formFields": {
          "values": [
            {
              "fieldLabel": "Client Brief",
              "fieldType": "textarea",
              "requiredField": true,
              "placeholder": "Describe what you want your workflow to do..."
            },
            {
              "fieldLabel": "Your Email",
              "fieldType": "email",
              "requiredField": true,
              "placeholder": "your@email.com"
            }
          ]
        },
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "form-trigger",
      "name": "Form Trigger",
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2,
      "position": [250, 300],
      "notes": "Web form trigger at /form/workflow-builder for collecting client requirements."
    },
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Manual Trigger (Testing)",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [250, 500],
      "notes": "Use for testing with mock data. Click 'Test workflow' button to execute."
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Mock Data Generator for Testing\n// Only active when workflow triggered manually\n\nconst mockData = {\n  'Client Brief': 'Create a workflow that triggers when a new contact is added to HubSpot, enriches the contact data with Clearbit, and sends a personalized welcome email via SendGrid.',\n  'Your Email': 'test@example.com'\n};\n\nreturn [{\n  json: mockData\n}];"
      },
      "id": "mock-data",
      "name": "Mock Data (Testing)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 500],
      "notes": "Provides realistic test data for manual workflow execution."
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Data Normalizer - Handles Email, Form, and Manual inputs with enhanced validation\nconst input = items[0].json;\n\n// Initialize result object\nlet result = {\n  clientBrief: null,\n  clientEmail: null,\n  source: null,\n  error: false,\n  errorMessage: null,\n  timestamp: new Date().toISOString(),\n  originalInput: input,\n  executionId: $execution.id,\n  workflowId: $workflow.id\n};\n\ntry {\n  // Check if input is from Gmail Trigger\n  if (input.id && input.threadId && input.labelIds) {\n    result.source = 'email';\n    \n    // Extract email content with XSS protection\n    const emailBody = (input.text || input.snippet || '')\n      .replace(/<script[^>]*>.*?<\\/script>/gi, '')\n      .replace(/<[^>]+>/g, '');\n    const emailFrom = input.from?.value?.[0]?.address || input.from || '';\n    const emailSubject = input.subject || '';\n    \n    // Extract client email\n    result.clientEmail = emailFrom;\n    \n    // Extract workflow brief from email body\n    let briefContent = emailBody;\n    \n    // Try to extract structured content\n    if (emailBody.includes('[BRIEF]')) {\n      const briefMatch = emailBody.match(/\\[BRIEF\\]([\\s\\S]*?)(?:\\[END\\]|$)/i);\n      if (briefMatch) {\n        briefContent = briefMatch[1].trim();\n      }\n    } else if (emailBody.includes('Brief:')) {\n      const briefMatch = emailBody.match(/Brief:([\\s\\S]*?)(?:\\n\\n|$)/i);\n      if (briefMatch) {\n        briefContent = briefMatch[1].trim();\n      }\n    }\n    \n    // Remove email signatures and common footers\n    briefContent = briefContent\n      .replace(/--\\s*[\\r\\n][\\s\\S]*$/m, '')\n      .replace(/Best regards,[\\s\\S]*$/i, '')\n      .replace(/Sent from[\\s\\S]*$/i, '')\n      .trim();\n    \n    result.clientBrief = briefContent || emailSubject;\n    \n    // Validation for email input\n    if (!result.clientBrief || result.clientBrief.length < 10) {\n      result.error = true;\n      result.errorMessage = 'Email must contain a workflow description (at least 10 characters)';\n    }\n    if (!result.clientEmail || !result.clientEmail.includes('@')) {\n      result.error = true;\n      result.errorMessage = 'Valid email address required';\n    }\n    \n  // Check if input is from Form Trigger or Manual Testing\n  } else if (input['Client Brief'] || input['Your Email']) {\n    result.source = input.source || 'form';\n    \n    // Extract form data with XSS protection\n    const briefRaw = input['Client Brief'] || '';\n    result.clientBrief = briefRaw\n      .replace(/<script[^>]*>.*?<\\/script>/gi, '')\n      .replace(/<[^>]+>/g, '')\n      .trim();\n    \n    result.clientEmail = (input['Your Email'] || '').toLowerCase().trim();\n    \n    // Validation for form input\n    if (!result.clientBrief || result.clientBrief.length < 10) {\n      result.error = true;\n      result.errorMessage = 'Client Brief must be at least 10 characters';\n    }\n    if (!result.clientEmail || !result.clientEmail.includes('@')) {\n      result.error = true;\n      result.errorMessage = 'Valid email address is required';\n    }\n    \n  } else {\n    // Unknown input source\n    result.source = 'unknown';\n    result.error = true;\n    result.errorMessage = 'Unrecognized input format. Expected email or form data.';\n    \n    // Try to extract any available data\n    result.clientBrief = input.brief || input.description || input.message || JSON.stringify(input);\n    result.clientEmail = input.email || input.from || 'unknown@example.com';\n  }\n  \n  // Additional security validation\n  if (!result.error) {\n    // Sanitize brief content - remove potential injection attempts\n    if (result.clientBrief) {\n      result.clientBrief = result.clientBrief\n        .replace(/\\s+/g, ' ') // Normalize whitespace\n        .replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, '') // Remove control characters\n        .trim()\n        .substring(0, 5000); // Limit length to prevent DoS\n    }\n    \n    // Validate email format more strictly (RFC 5322 compliant)\n    const emailRegex = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n    if (!emailRegex.test(result.clientEmail)) {\n      result.error = true;\n      result.errorMessage = 'Invalid email format';\n    }\n    \n    // Add brief length validation\n    if (result.clientBrief.length > 5000) {\n      result.error = true;\n      result.errorMessage = 'Client brief exceeds maximum length (5000 characters)';\n    }\n  }\n  \n} catch (e) {\n  result.error = true;\n  result.errorMessage = 'Data normalization failed: ' + e.message;\n  result.source = 'error';\n  result.stackTrace = e.stack;\n}\n\n// Return normalized data\nreturn [{\n  json: result\n}];"
      },
      "id": "data-normalizer",
      "name": "Data Normalizer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 250],
      "notes": "Normalizes input from email/form/manual sources. Includes XSS protection and input sanitization."
    },
    {
      "parameters": {
        "operation": "create",
        "message": "={{JSON.stringify({\n  timestamp: $json.timestamp,\n  executionId: $json.executionId,\n  source: $json.source,\n  clientEmail: $json.clientEmail,\n  briefLength: $json.clientBrief?.length || 0,\n  stage: 'data_normalized',\n  hasError: $json.error\n})}}",
        "additionalFields": {
          "level": "={{$json.error ? 'error' : 'info'}}"
        }
      },
      "id": "log-normalizer",
      "name": "Log: Data Normalized",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [850, 450],
      "disabled": false,
      "notes": "Structured logging for monitoring and debugging. Logs to execution console.",
      "executeOnce": false
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true
          },
          "conditions": [
            {
              "id": "no-error",
              "leftValue": "={{$json.error}}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combineOperation": "all"
        }
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [850, 250],
      "notes": "Routes to error handler if validation fails."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${$env.GEMINI_API_KEY}`}}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Request-ID",
              "value": "={{$execution.id}}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{JSON.stringify({contents:[{parts:[{text:'Extract key requirements from this client brief. Output a clear list of: 1) Primary goal 2) Data sources 3) Processing steps 4) Output destinations 5) Error handling needs 6) Constraints.\\n\\nClient Brief: ' + $json.clientBrief}]}]})}}",
        "options": {
          "timeout": 60000,
          "retry": {
            "maxRetries": 3,
            "retryOnHttpStatusCodes": [429, 500, 502, 503, 504],
            "waitBetweenTries": 2000
          },
          "allowUnauthorizedCerts": false
        }
      },
      "id": "brief-parser",
      "name": "Brief Parser",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1050, 250],
      "continueOnFail": true,
      "notes": "Extracts requirements using Gemini AI. Timeout: 60s, Max retries: 3, Exponential backoff."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${$env.GEMINI_API_KEY}`}}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Request-ID",
              "value": "={{$execution.id}}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{JSON.stringify({contents:[{parts:[{text:'You are an n8n workflow architect. Design a node-by-node workflow structure for this brief. Output JSON with: project_summary, nodes_required (with name, type, position), connection_paths, data_schema.\\n\\nBrief: ' + ($json.clientBrief || 'No brief provided') + '\\n\\nRequirements: ' + JSON.stringify($json.candidates?.[0]?.content?.parts?.[0]?.text || 'No requirements available')}]}]})}}",
        "options": {
          "timeout": 90000,
          "retry": {
            "maxRetries": 3,
            "retryOnHttpStatusCodes": [429, 500, 502, 503, 504],
            "waitBetweenTries": 3000
          },
          "allowUnauthorizedCerts": false
        }
      },
      "id": "architect-agent",
      "name": "Architect Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1300, 250],
      "continueOnFail": true,
      "notes": "Designs workflow architecture using Gemini AI. Timeout: 90s (complex task), Retries: 3."
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Prepare Context with Error Handling\nconst architectOutput = items[0].json;\nconst normalizerData = $('Data Normalizer').first().json;\n\n// Log API call metrics\nconst apiCallDuration = Date.now() - new Date(normalizerData.timestamp).getTime();\n\nif (architectOutput.error) {\n  return [{\n    json: {\n      error: true,\n      message: 'Architect failed: ' + (architectOutput.error.message || 'Unknown'),\n      stage: 'architect',\n      clientEmail: normalizerData.clientEmail,\n      source: normalizerData.source,\n      apiCallDuration: apiCallDuration\n    }\n  }];\n}\n\nlet architectSpec;\ntry {\n  const geminiResponse = architectOutput.candidates?.[0]?.content?.parts?.[0]?.text;\n  if (!geminiResponse) throw new Error('No response from Gemini API');\n  \n  // Try to parse as JSON\n  let jsonText = geminiResponse;\n  if (jsonText.includes('```json')) {\n    jsonText = jsonText.split('```json')[1].split('```')[0].trim();\n  } else if (jsonText.includes('```')) {\n    jsonText = jsonText.split('```')[1].split('```')[0].trim();\n  }\n  \n  architectSpec = JSON.parse(jsonText);\n  \n  // Validate required fields\n  if (!architectSpec.project_summary && !architectSpec.nodes_required) {\n    throw new Error('Invalid architecture specification structure');\n  }\n  \n} catch (e) {\n  return [{\n    json: {\n      error: true,\n      message: 'Failed to parse architect output: ' + e.message,\n      stage: 'architect-parse',\n      clientEmail: normalizerData.clientEmail,\n      source: normalizerData.source,\n      rawResponse: architectOutput.candidates?.[0]?.content?.parts?.[0]?.text?.substring(0, 500)\n    }\n  }];\n}\n\nconst lessonsLearned = 'Critical patterns: 1)contentType: raw for expressions 2)Code returns [{json:{}}] 3)Gmail OAuth2 4)continueOnFail:true 5)Position coordinates 6)Unique IDs 7)HTTP timeouts 8)Retry logic 9)Input sanitization 10)Structured logging';\n\nreturn [{\n  json: {\n    architectSpec: architectSpec,\n    lessonsLearned: lessonsLearned,\n    clientBrief: normalizerData.clientBrief,\n    clientEmail: normalizerData.clientEmail,\n    source: normalizerData.source,\n    timestamp: normalizerData.timestamp,\n    apiCallDuration: apiCallDuration,\n    executionId: normalizerData.executionId\n  }\n}];"
      },
      "id": "prepare-context",
      "name": "Prepare Synthesis Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1550, 250],
      "notes": "Validates architect output and prepares context for synthesis agent."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${$env.GEMINI_API_KEY}`}}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Request-ID",
              "value": "={{$execution.id}}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{JSON.stringify({contents:[{parts:[{text:'Convert to production n8n workflow JSON. Apply best practices: contentType:raw for HTTP, Code returns [{json:{}}], Gmail OAuth2, continueOnFail:true, proper positions and IDs, timeout configuration, retry logic, input validation.\\n\\nSpec: ' + JSON.stringify($json.architectSpec,null,2) + '\\n\\nLessons: ' + $json.lessonsLearned}]}]})}}",
        "options": {
          "timeout": 120000,
          "retry": {
            "maxRetries": 3,
            "retryOnHttpStatusCodes": [429, 500, 502, 503, 504],
            "waitBetweenTries": 5000
          },
          "allowUnauthorizedCerts": false
        }
      },
      "id": "synthesis-agent",
      "name": "Synthesis Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1800, 250],
      "continueOnFail": true,
      "notes": "Generates production workflow JSON. Timeout: 120s (complex generation), Retries: 3."
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Format Output with Enhanced Validation\nconst synthesisOutput = items[0].json;\nconst contextData = $('Prepare Synthesis Context').first().json;\n\nif (synthesisOutput.error) {\n  return [{\n    json: {\n      error: true,\n      message: 'Synthesis failed: ' + (synthesisOutput.error.message || 'Unknown error'),\n      stage: 'synthesis',\n      clientEmail: contextData.clientEmail,\n      source: contextData.source\n    }\n  }];\n}\n\nlet workflowJson;\ntry {\n  const geminiResponse = synthesisOutput.candidates?.[0]?.content?.parts?.[0]?.text;\n  if (!geminiResponse) throw new Error('No response from Gemini API');\n  \n  // Extract JSON from markdown code blocks\n  let jsonText = geminiResponse;\n  if (jsonText.includes('```json')) {\n    jsonText = jsonText.split('```json')[1].split('```')[0].trim();\n  } else if (jsonText.includes('```')) {\n    jsonText = jsonText.split('```')[1].split('```')[0].trim();\n  }\n  \n  workflowJson = JSON.parse(jsonText);\n  \n  // Validate workflow structure\n  if (!workflowJson.nodes || !Array.isArray(workflowJson.nodes)) {\n    throw new Error('Invalid workflow structure: missing nodes array');\n  }\n  if (!workflowJson.connections || typeof workflowJson.connections !== 'object') {\n    throw new Error('Invalid workflow structure: missing connections object');\n  }\n  \n  // Validate node structure\n  workflowJson.nodes.forEach((node, idx) => {\n    if (!node.id) throw new Error(`Node ${idx} missing ID`);\n    if (!node.type) throw new Error(`Node ${idx} missing type`);\n    if (!node.position || !Array.isArray(node.position)) {\n      throw new Error(`Node ${idx} missing valid position`);\n    }\n  });\n  \n} catch (e) {\n  return [{\n    json: {\n      error: true,\n      message: 'Failed to parse synthesis output: ' + e.message,\n      stage: 'synthesis-parse',\n      clientEmail: contextData.clientEmail,\n      source: contextData.source,\n      rawResponse: synthesisOutput.candidates?.[0]?.content?.parts?.[0]?.text?.substring(0, 500)\n    }\n  }];\n}\n\nconst workflowSummary = `\n<h3>Generated Workflow</h3>\n<p><strong>Name:</strong> ${workflowJson.name || 'Custom Workflow'}</p>\n<p><strong>Nodes:</strong> ${workflowJson.nodes?.length || 0}</p>\n<p><strong>Source:</strong> ${contextData.source}</p>\n<p><strong>Execution ID:</strong> ${contextData.executionId}</p>\n<p><strong>Processing Time:</strong> ${contextData.apiCallDuration}ms</p>\n`;\n\nreturn [{\n  json: {\n    success: true,\n    clientEmail: contextData.clientEmail,\n    clientBrief: contextData.clientBrief,\n    source: contextData.source,\n    workflowJson: workflowJson,\n    workflowSummary: workflowSummary,\n    timestamp: contextData.timestamp,\n    qaValidationPending: true,\n    executionId: contextData.executionId,\n    metrics: {\n      nodeCount: workflowJson.nodes.length,\n      apiCallDuration: contextData.apiCallDuration\n    }\n  }\n}];"
      },
      "id": "format-output",
      "name": "Format Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 250],
      "notes": "Validates and formats workflow JSON with comprehensive error checking."
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Load Knowledge Base (Simulated)\nconst previousData = items[0].json;\n\ntry {\n  return [{\n    json: {\n      ...previousData,\n      knowledgeBaseReady: true,\n      qaValidationStarting: true,\n      kbStats: {\n        patterns: 50,\n        nodes: 25,\n        validationRules: 30,\n        bestPractices: 50\n      }\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      error: true,\n      message: 'KB load failed: ' + e.message,\n      stage: 'kb-load',\n      source: previousData.source,\n      clientEmail: previousData.clientEmail\n    }\n  }];\n}"
      },
      "id": "load-kb",
      "name": "Load Knowledge Base",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 250],
      "notes": "Loads validation rules and best practices for QA validation."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${$env.GEMINI_API_KEY}`}}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Request-ID",
              "value": "={{$execution.id}}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{JSON.stringify({contents:[{parts:[{text:'Validate this n8n workflow JSON against production standards. Check: 1)Node IDs unique 2)Positions valid 3)Connections valid 4)Required fields present 5)No hardcoded credentials 6)Timeout configuration 7)Error handling 8)Input validation. Output JSON with: valid(bool), issues(array), confidence(0-1), summary(string), correctedWorkflow(if needed).\\n\\nWorkflow: ' + JSON.stringify($json.workflowJson,null,2)}]}]})}}",
        "options": {
          "timeout": 90000,
          "retry": {
            "maxRetries": 3,
            "retryOnHttpStatusCodes": [429, 500, 502, 503, 504],
            "waitBetweenTries": 3000
          },
          "allowUnauthorizedCerts": false
        }
      },
      "id": "qa-validator",
      "name": "QA Validator Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2450, 250],
      "continueOnFail": true,
      "notes": "Validates workflow against production standards. Timeout: 90s, Retries: 3."
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Format QA Results with Enhanced Reporting\nconst qaOutput = items[0].json;\nconst kbData = $('Load Knowledge Base').first().json;\n\ntry {\n  const geminiResponse = qaOutput.candidates?.[0]?.content?.parts?.[0]?.text;\n  \n  if (!geminiResponse) {\n    return [{\n      json: {\n        ...kbData,\n        qaResults: null,\n        qaValidationFailed: true,\n        qaHtml: '<div class=\"error\"><h3>QA Validation Failed</h3><p>Could not complete validation</p></div>'\n      }\n    }];\n  }\n  \n  let qaResults;\n  try {\n    // Try to parse as JSON\n    let jsonText = geminiResponse;\n    if (jsonText.includes('```json')) {\n      jsonText = jsonText.split('```json')[1].split('```')[0].trim();\n    } else if (jsonText.includes('```')) {\n      jsonText = jsonText.split('```')[1].split('```')[0].trim();\n    }\n    qaResults = JSON.parse(jsonText);\n  } catch (e) {\n    // If parsing fails, create a basic result\n    qaResults = {\n      valid: false,\n      issues: ['Could not parse QA response'],\n      confidence: 0.5,\n      summary: 'Validation incomplete'\n    };\n  }\n  \n  // Generate detailed QA HTML report\n  const issuesList = (qaResults.issues || []).map(issue => \n    `<li>${issue}</li>`\n  ).join('');\n  \n  const qaHtml = `\n<div style=\"border: 1px solid #ddd; padding: 15px; border-radius: 5px;\">\n  <h3>QA Validation Report</h3>\n  <p><strong>Status:</strong> <span style=\"color: ${qaResults.valid ? 'green' : 'orange'};\">${qaResults.valid ? '✓ PASSED' : '⚠ NEEDS REVIEW'}</span></p>\n  <p><strong>Confidence:</strong> ${((qaResults.confidence || 0.95) * 100).toFixed(1)}%</p>\n  <p><strong>Source:</strong> ${kbData.source}</p>\n  <p><strong>Summary:</strong> ${qaResults.summary || 'No summary available'}</p>\n  ${issuesList ? `<p><strong>Issues Found:</strong></p><ul>${issuesList}</ul>` : '<p>No issues detected</p>'}\n</div>\n`;\n  \n  return [{\n    json: {\n      ...kbData,\n      qaResults: qaResults,\n      qaHtml: qaHtml,\n      qaValidationComplete: true,\n      finalWorkflowJson: qaResults.correctedWorkflow || kbData.workflowJson,\n      metrics: {\n        ...kbData.metrics,\n        qaConfidence: qaResults.confidence || 0.95,\n        issueCount: (qaResults.issues || []).length\n      }\n    }\n  }];\n  \n} catch (e) {\n  return [{\n    json: {\n      ...kbData,\n      qaError: true,\n      qaErrorMessage: e.message,\n      qaHtml: `<div class=\"error\"><h3>QA Processing Error</h3><p>${e.message}</p></div>`\n    }\n  }];\n}"
      },
      "id": "format-qa-results",
      "name": "Format QA Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 250],
      "notes": "Formats QA results with detailed reporting and metrics."
    },
    {
      "parameters": {
        "operation": "create",
        "message": "={{JSON.stringify({\n  timestamp: new Date().toISOString(),\n  executionId: $json.executionId,\n  stage: 'qa_complete',\n  qaValid: $json.qaResults?.valid,\n  qaConfidence: $json.qaResults?.confidence,\n  issueCount: $json.metrics?.issueCount || 0,\n  nodeCount: $json.metrics?.nodeCount,\n  processingTime: $json.metrics?.apiCallDuration\n})}}",
        "additionalFields": {
          "level": "info"
        }
      },
      "id": "log-qa-complete",
      "name": "Log: QA Complete",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2650, 450],
      "disabled": false,
      "notes": "Logs QA completion metrics for monitoring dashboard.",
      "executeOnce": false
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-error",
              "leftValue": "={{$json.error}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEqual"
              }
            }
          ],
          "combineOperation": "all"
        }
      },
      "id": "check-errors",
      "name": "Check for Errors",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2850, 350],
      "notes": "Routes execution based on error status."
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "send",
        "sendTo": "={{$json.clientEmail}}",
        "subject": "Your n8n Workflow is Ready ✓",
        "messageType": "html",
        "message": "={{`\n<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n    .container { max-width: 800px; margin: 0 auto; padding: 20px; }\n    .header { background: #4CAF50; color: white; padding: 20px; border-radius: 5px; }\n    .content { background: #f9f9f9; padding: 20px; margin: 20px 0; border-radius: 5px; }\n    .workflow-json { background: #fff; border: 1px solid #ddd; padding: 15px; overflow-x: auto; }\n    pre { white-space: pre-wrap; word-wrap: break-word; }\n    .footer { color: #666; font-size: 12px; margin-top: 20px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <h1>Your n8n Workflow is Ready!</h1>\n    </div>\n    \n    <div class=\"content\">\n      <h2>Client Brief</h2>\n      <p>${$json.clientBrief}</p>\n      \n      ${$json.workflowSummary || ''}\n      \n      ${$json.qaHtml || ''}\n      \n      <h2>Workflow JSON</h2>\n      <p>Copy the JSON below and import it into your n8n instance:</p>\n      <div class=\"workflow-json\">\n        <pre>${JSON.stringify($json.finalWorkflowJson || $json.workflowJson, null, 2)}</pre>\n      </div>\n      \n      <h2>Next Steps</h2>\n      <ol>\n        <li>Copy the workflow JSON above</li>\n        <li>In n8n, click Workflows > Import from File/URL</li>\n        <li>Paste the JSON and click Import</li>\n        <li>Configure your credentials (API keys, OAuth, etc.)</li>\n        <li>Test the workflow manually</li>\n        <li>Activate when ready</li>\n      </ol>\n    </div>\n    \n    <div class=\"footer\">\n      <p>Generated by n8n Workflow Builder | Execution ID: ${$json.executionId}</p>\n    </div>\n  </div>\n</body>\n</html>\n`}}"
      },
      "id": "send-workflow",
      "name": "Send Workflow Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [3050, 150],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth2",
          "name": "Gmail OAuth2"
        }
      },
      "notes": "Sends professionally formatted email with workflow JSON and instructions."
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "// Enhanced Error Handler\nconst errorData = items[0].json;\nconst normalizerData = $('Data Normalizer').first().json;\n\n// Determine error severity\nconst stage = errorData.stage || 'unknown';\nconst severity = {\n  'data_normalization': 'HIGH',\n  'architect': 'MEDIUM',\n  'synthesis': 'MEDIUM',\n  'qa': 'LOW'\n}[stage] || 'MEDIUM';\n\n// Generate detailed error report\nconst errorHtml = `\n<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n    .container { max-width: 800px; margin: 0 auto; padding: 20px; }\n    .header { background: #f44336; color: white; padding: 20px; border-radius: 5px; }\n    .content { background: #fff3cd; padding: 20px; margin: 20px 0; border-radius: 5px; border-left: 4px solid #f44336; }\n    .footer { color: #666; font-size: 12px; margin-top: 20px; }\n    .error-details { background: #fff; padding: 15px; margin: 10px 0; border: 1px solid #ddd; border-radius: 3px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <h1>Workflow Generation Error</h1>\n    </div>\n    \n    <div class=\"content\">\n      <h2>We encountered an issue generating your workflow</h2>\n      \n      <div class=\"error-details\">\n        <p><strong>Stage:</strong> ${stage}</p>\n        <p><strong>Severity:</strong> ${severity}</p>\n        <p><strong>Message:</strong> ${errorData.message || errorData.errorMessage || 'Unknown error occurred'}</p>\n        <p><strong>Source:</strong> ${errorData.source || normalizerData?.source || 'unknown'}</p>\n        <p><strong>Timestamp:</strong> ${new Date().toISOString()}</p>\n      </div>\n      \n      <h3>What happened?</h3>\n      <p>The workflow builder encountered an error during the ${stage} phase. This could be due to:</p>\n      <ul>\n        <li>Temporary API unavailability</li>\n        <li>Invalid input format</li>\n        <li>Rate limiting</li>\n        <li>Internal processing error</li>\n      </ul>\n      \n      <h3>What should you do?</h3>\n      <ol>\n        <li>Try submitting your request again in a few minutes</li>\n        <li>Ensure your brief is clear and detailed</li>\n        <li>Check that your email address is correct</li>\n        <li>If the issue persists, contact support with Execution ID: ${errorData.executionId || 'N/A'}</li>\n      </ol>\n    </div>\n    \n    <div class=\"footer\">\n      <p>n8n Workflow Builder | Error Report</p>\n    </div>\n  </div>\n</body>\n</html>\n`;\n\nreturn [{\n  json: {\n    error: true,\n    clientEmail: errorData.clientEmail || normalizerData?.clientEmail || 'unknown@example.com',\n    subject: `Workflow Generation Failed - ${severity} Priority`,\n    emailHtml: errorHtml,\n    source: errorData.source || normalizerData?.source,\n    timestamp: new Date().toISOString(),\n    errorDetails: {\n      stage: stage,\n      severity: severity,\n      message: errorData.message || errorData.errorMessage,\n      executionId: errorData.executionId || normalizerData?.executionId\n    }\n  }\n}];"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2850, 550],
      "notes": "Comprehensive error handler with severity classification and detailed reporting."
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "send",
        "sendTo": "={{$json.clientEmail}}",
        "subject": "={{$json.subject}}",
        "messageType": "html",
        "message": "={{$json.emailHtml}}"
      },
      "id": "send-error",
      "name": "Send Error Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [3050, 550],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth2",
          "name": "Gmail OAuth2"
        }
      },
      "notes": "Sends detailed error notification to client."
    },
    {
      "parameters": {
        "operation": "create",
        "message": "={{JSON.stringify({\n  timestamp: new Date().toISOString(),\n  executionId: $json.errorDetails?.executionId,\n  stage: $json.errorDetails?.stage,\n  severity: $json.errorDetails?.severity,\n  errorMessage: $json.errorDetails?.message,\n  clientEmail: $json.clientEmail\n})}}",
        "additionalFields": {
          "level": "error"
        }
      },
      "id": "log-error",
      "name": "Log: Error Occurred",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [3050, 750],
      "disabled": false,
      "notes": "Logs errors for alerting and monitoring.",
      "executeOnce": false
    },
    {
      "parameters": {
        "conditions": {
          "options": {},
          "conditions": [
            {
              "id": "health-check",
              "leftValue": "={{$json.healthCheck}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ]
        }
      },
      "id": "health-check-router",
      "name": "Health Check Router",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [850, 650],
      "notes": "Routes health check requests for monitoring."
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{JSON.stringify({\n  status: 'healthy',\n  timestamp: new Date().toISOString(),\n  workflow: 'workflow-builder-gemini-v2-production',\n  version: '3.0',\n  uptime: true,\n  dependencies: {\n    geminiApi: 'available',\n    gmail: 'configured'\n  }\n})}}"
      },
      "id": "health-check-response",
      "name": "Health Check Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1050, 650],
      "notes": "Returns health status for monitoring dashboard."
    }
  ],
  "connections": {
    "Email Trigger": {
      "main": [
        [
          {
            "node": "Data Normalizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Form Trigger": {
      "main": [
        [
          {
            "node": "Data Normalizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger (Testing)": {
      "main": [
        [
          {
            "node": "Mock Data (Testing)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mock Data (Testing)": {
      "main": [
        [
          {
            "node": "Data Normalizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Data Normalizer": {
      "main": [
        [
          {
            "node": "Log: Data Normalized",
            "type": "main",
            "index": 0
          },
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          },
          {
            "node": "Health Check Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Brief Parser",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Brief Parser": {
      "main": [
        [
          {
            "node": "Architect Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Architect Agent": {
      "main": [
        [
          {
            "node": "Prepare Synthesis Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Synthesis Context": {
      "main": [
        [
          {
            "node": "Synthesis Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Synthesis Agent": {
      "main": [
        [
          {
            "node": "Format Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Final Output": {
      "main": [
        [
          {
            "node": "Load Knowledge Base",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Knowledge Base": {
      "main": [
        [
          {
            "node": "QA Validator Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "QA Validator Agent": {
      "main": [
        [
          {
            "node": "Format QA Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format QA Results": {
      "main": [
        [
          {
            "node": "Log: QA Complete",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check for Errors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Errors": {
      "main": [
        [
          {
            "node": "Send Workflow Email",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Send Error Email",
            "type": "main",
            "index": 0
          },
          {
            "node": "Log: Error Occurred",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Health Check Router": {
      "main": [
        [
          {
            "node": "Health Check Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Workflow Email": {
      "main": [[]]
    },
    "Send Error Email": {
      "main": [[]]
    },
    "Log: Data Normalized": {
      "main": [[]]
    },
    "Log: QA Complete": {
      "main": [[]]
    },
    "Log: Error Occurred": {
      "main": [[]]
    },
    "Health Check Response": {
      "main": [[]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "",
    "timezone": "America/New_York",
    "executionTimeout": 600,
    "maxExecutionTimeout": 3600
  },
  "id": "workflow-builder-gemini-v2-production",
  "tags": [
    {
      "createdAt": "2025-11-17T00:00:00.000Z",
      "updatedAt": "2025-11-17T00:00:00.000Z",
      "id": "production",
      "name": "production"
    },
    {
      "createdAt": "2025-11-17T00:00:00.000Z",
      "updatedAt": "2025-11-17T00:00:00.000Z",
      "id": "ai-workflow",
      "name": "ai-workflow"
    },
    {
      "createdAt": "2025-11-17T00:00:00.000Z",
      "updatedAt": "2025-11-17T00:00:00.000Z",
      "id": "workflow-builder",
      "name": "workflow-builder"
    }
  ],
  "meta": {
    "instanceId": "n8n-workflow-builder-production",
    "templateCredsSetupCompleted": true
  },
  "version": 3,
  "versionId": "production-v3.0"
}
