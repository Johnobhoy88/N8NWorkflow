# Expression Edge Case Handling Documentation

**Workflow:** workflow-builder-gemini-v2-with-qa-enhanced.json
**Version:** 3.0
**Last Updated:** 2025-11-17
**Status:** Production-Safe

## Overview

This document outlines all edge cases handled in the workflow expressions and provides guidance for maintaining production-safe expression patterns.

---

## Table of Contents

1. [Critical Edge Cases](#critical-edge-cases)
2. [Warning-Level Edge Cases](#warning-level-edge-cases)
3. [Expression Patterns](#expression-patterns)
4. [Testing Scenarios](#testing-scenarios)
5. [Troubleshooting](#troubleshooting)
6. [Best Practices](#best-practices)

---

## Critical Edge Cases

### 1. Unsafe Nested Path Access (Line 137)

**Location:** Architect Agent - HTTP Request Body

**Problem:**
```javascript
// ❌ UNSAFE - Will crash if any intermediate property is null/undefined
$json.candidates[0].content.parts[0].text
```

**Solution:**
```javascript
// ✅ SAFE - Uses optional chaining with fallback
$json.candidates?.[0]?.content?.parts?.[0]?.text || 'No requirements available'
```

**Edge Cases Handled:**
- Missing `candidates` array → Returns fallback
- Empty `candidates` array → Returns fallback
- Null `content` object → Returns fallback
- Missing `parts` array → Returns fallback
- Missing `text` property → Returns fallback
- Entire `$json` is null/undefined → Returns fallback

**Impact:** CRITICAL - Without this fix, workflow crashes when Gemini API returns unexpected response structure

---

### 2. XSS Vulnerability in Email Template (Line 276)

**Location:** Send Workflow Email - Message Parameter

**Problem:**
```javascript
// ❌ UNSAFE - Allows script injection
`<h2>Your Workflow</h2><p>Brief: ${$json.clientBrief}</p>`
```

**Solution:**
```javascript
// ✅ SAFE - HTML escapes all user input
(() => {
  const escape = (str) => (str || '').toString()
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

  const brief = escape($json.clientBrief);
  const workflowJson = escape(JSON.stringify($json.finalWorkflowJson || $json.workflowJson, null, 2));

  return `<h2>Your Workflow</h2><p>Brief: ${brief}</p>${$json.workflowSummary || ''}<pre>${workflowJson}</pre>${$json.qaHtml || ''}`;
})()
```

**Edge Cases Handled:**
- Script tag injection: `<script>alert('XSS')</script>` → Escaped
- Image onerror injection: `<img src=x onerror=alert(1)>` → Escaped
- Event handler injection: `<div onclick="...">` → Escaped
- SQL injection characters: `'; DROP TABLE` → Escaped
- Double/single quotes: `"` and `'` → Escaped
- Null/undefined input → Empty string

**Impact:** CRITICAL - Prevents execution of malicious code in recipient's email client

**Security Notes:**
- `$json.workflowSummary` and `$json.qaHtml` are generated by Code nodes and are considered safe
- If these become user-editable, they must also be escaped
- JSON stringification provides additional layer of encoding

---

### 3. Inconsistent Expression Syntax (Line 306)

**Location:** Send Error Email - Subject Parameter

**Problem:**
```javascript
// ❌ INCORRECT - Missing equals sign
"subject": "{{$json.subject}}"
```

**Solution:**
```javascript
// ✅ CORRECT - Proper n8n expression syntax with fallback
"subject": "={{$json?.subject || 'Workflow Error'}}"
```

**Edge Cases Handled:**
- Missing subject property → "Workflow Error"
- Null subject → "Workflow Error"
- Empty string subject → "Workflow Error"
- Undefined $json → "Workflow Error"

**Impact:** CRITICAL - Without `=`, n8n treats it as literal string, not expression

**Syntax Rules:**
- `={{...}}` - Expression that evaluates to value
- `{{...}}` - String interpolation (deprecated in newer n8n)
- Always use `={{...}}` for consistency and clarity

---

## Warning-Level Edge Cases

### 4. Email Address Validation (Lines 273, 305)

**Locations:**
- Send Workflow Email - sendTo parameter
- Send Error Email - sendTo parameter

**Problem:**
```javascript
// ❌ UNSAFE - Could send to invalid address or crash
"sendTo": "={{$json.clientEmail}}"
```

**Solution:**
```javascript
// ✅ SAFE - Validates email format before using
"sendTo": "={{(() => {
  const email = $json?.clientEmail || '';
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email) ? email : 'noreply@example.com';
})()}}"
```

**Edge Cases Handled:**
- Missing `@` symbol → Fallback email
- Missing domain → Fallback email
- Spaces in email → Fallback email
- Empty string → Fallback email
- Null/undefined → Fallback email
- Invalid TLD → Fallback email

**Impact:** MEDIUM - Prevents email delivery failures

**Email Regex Breakdown:**
- `^[^\s@]+` - One or more non-space, non-@ characters (local part)
- `@` - Literal @ symbol
- `[^\s@]+` - One or more non-space, non-@ characters (domain)
- `\.` - Literal dot
- `[^\s@]+$` - One or more characters (TLD)

**Limitations:**
- Does not validate against full RFC 5322 spec
- Does not check if domain exists
- Does not prevent disposable email addresses
- Good enough for basic validation

**Fallback Email:**
- `noreply@example.com` is used as fallback
- Should be configured to your actual no-reply address
- Consider logging these failures for investigation

---

### 5. Boolean Error Checks (Lines 79, 251)

**Locations:**
- Validate Input - IF node condition
- Check for Errors - IF node condition

**Problem:**
```javascript
// ❌ UNSAFE - Crashes if $json is null
"leftValue": "={{$json.error}}"
```

**Solution:**
```javascript
// ✅ SAFE - Defaults to false if missing
"leftValue": "={{$json?.error ?? false}}"
```

**Edge Cases Handled:**
- `error: true` → true
- `error: false` → false
- `error: null` → false
- `error: undefined` → false
- Missing error property → false
- Entire $json is null → false

**Impact:** MEDIUM - Prevents workflow routing errors

**Nullish Coalescing (`??`) vs OR (`||`):**
```javascript
false ?? 'fallback'  // → false (only null/undefined trigger fallback)
false || 'fallback'  // → 'fallback' (falsy values trigger fallback)

0 ?? 'fallback'      // → 0
0 || 'fallback'      // → 'fallback'

'' ?? 'fallback'     // → ''
'' || 'fallback'     // → 'fallback'
```

**Why we use `??` here:**
- `error: false` is a valid state (no error)
- `||` would incorrectly treat false as "use fallback"
- `??` only triggers fallback for null/undefined

---

### 6. Environment Variable Validation (Lines 99, 124, 160, 207)

**Locations:** All Gemini API HTTP Request nodes

**Problem:**
```javascript
// ❌ UNSAFE - Empty URL if env var missing
`https://api.example.com?key=${$env.GEMINI_API_KEY}`
```

**Solution:**
```javascript
// ✅ SAFE - Defaults to empty string (will fail with clear error)
`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${$env.GEMINI_API_KEY || ''}`
```

**Edge Cases Handled:**
- API key not set → Empty string (API returns 401)
- API key is null → Empty string
- API key is undefined → Empty string
- Env object missing → Empty string

**Impact:** MEDIUM - Provides clear error instead of crash

**Why not throw error immediately?**
- n8n's `continueOnFail: true` handles API errors gracefully
- Error Handler node catches and reports the issue
- Client receives clear "API configuration error" message
- Better than crashing entire workflow

**Production Setup:**
- MUST set `GEMINI_API_KEY` in n8n environment variables
- Test with missing key to verify error handling
- Monitor for 401 errors in production logs

---

### 7. Data Fallbacks in HTTP Request Bodies

**Locations:**
- Line 112: Brief Parser
- Line 137: Architect Agent (covered in Critical #1)
- Line 173: Synthesis Agent
- Line 220: QA Validator

**Problem:**
```javascript
// ❌ UNSAFE - Sends "undefined" or crashes
'Client Brief: ' + $json.clientBrief
```

**Solution:**
```javascript
// ✅ SAFE - Always sends valid string
'Client Brief: ' + ($json?.clientBrief || 'No brief provided')
```

**Edge Cases Handled:**
- Valid brief string → Used as-is
- Empty string → Fallback message
- Null → Fallback message
- Undefined → Fallback message
- Missing property → Fallback message

**Impact:** LOW-MEDIUM - Prevents Gemini API from receiving malformed requests

**Fallback Messages:**
- Brief Parser: `'No brief provided'`
- Architect Agent: `'No requirements available'`
- Synthesis Agent: `{error: 'No spec available'}`
- QA Validator: `{error: 'No workflow available'}`

**Why different fallbacks?**
- String fields → Descriptive string message
- JSON fields → Error object for structured parsing
- Helps downstream Code nodes identify which stage failed

---

### 8. JSON Stringification Safety (Lines 173, 220)

**Locations:**
- Synthesis Agent - architectSpec
- QA Validator - workflowJson

**Problem:**
```javascript
// ❌ UNSAFE - Crashes on circular references or non-objects
JSON.stringify($json.architectSpec, null, 2)
```

**Solution:**
```javascript
// ✅ SAFE - Provides error object as fallback
JSON.stringify($json?.architectSpec || {error: 'No spec available'}, null, 2)
```

**Edge Cases Handled:**
- Valid object → Stringified normally
- Null object → Error object stringified
- Undefined object → Error object stringified
- Missing property → Error object stringified

**Circular Reference Handling:**
- n8n's JSON.stringify doesn't prevent circular reference errors
- Objects from Gemini API should never have circular refs
- If needed, implement custom replacer function:
  ```javascript
  const seen = new WeakSet();
  JSON.stringify(obj, (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (seen.has(value)) return "[Circular]";
      seen.add(value);
    }
    return value;
  }, 2);
  ```

**Impact:** LOW - Gemini API responses are always safe to stringify

---

### 9. HTML Content Fallbacks (Line 308)

**Location:** Send Error Email - message parameter

**Problem:**
```javascript
// ❌ UNSAFE - Could send empty email
"message": "={{$json.emailHtml}}"
```

**Solution:**
```javascript
// ✅ SAFE - Always sends valid HTML
"message": "={{$json?.emailHtml || '<p>An error occurred during workflow generation.</p>'}}"
```

**Edge Cases Handled:**
- Valid HTML string → Used as-is
- Empty string → Generic error message
- Null → Generic error message
- Undefined → Generic error message

**Impact:** LOW - Ensures clients always receive error notification

---

## Expression Patterns

### Pattern 1: Safe Property Access

```javascript
// ❌ UNSAFE
$json.property

// ✅ SAFE - with default value
$json?.property || 'default'

// ✅ SAFE - with nullish coalescing (preserves falsy values)
$json?.property ?? 'default'
```

**When to use:**
- `||` - When you want to replace ALL falsy values (0, '', false, null, undefined)
- `??` - When you want to replace ONLY null/undefined

### Pattern 2: Deep Property Access

```javascript
// ❌ UNSAFE
$json.level1.level2.level3.value

// ✅ SAFE
$json?.level1?.level2?.level3?.value || 'fallback'

// ✅ SAFE - array access
$json?.array?.[0]?.property || 'fallback'
```

### Pattern 3: HTML Escaping

```javascript
// ❌ UNSAFE
`<p>${userInput}</p>`

// ✅ SAFE
(() => {
  const escape = (str) => (str || '').toString()
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
  return `<p>${escape(userInput)}</p>`;
})()
```

### Pattern 4: Email Validation

```javascript
// ❌ UNSAFE
$json.email

// ✅ SAFE
(() => {
  const email = $json?.email || '';
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email) ? email : 'fallback@example.com';
})()
```

### Pattern 5: Environment Variables

```javascript
// ❌ UNSAFE
$env.VARIABLE

// ✅ SAFE
$env.VARIABLE || 'fallback'

// ✅ BETTER - throw error if critical
$env.VARIABLE || (() => { throw new Error('VARIABLE not set'); })()
```

### Pattern 6: Type Coercion Safety

```javascript
// ❌ UNSAFE - could concatenate strings instead of adding
$json.num1 + $json.num2

// ✅ SAFE - explicit number conversion
Number($json?.num1 || 0) + Number($json?.num2 || 0)

// ❌ UNSAFE - could compare strings
$json.value > 10

// ✅ SAFE
Number($json?.value || 0) > 10
```

### Pattern 7: Array Safety

```javascript
// ❌ UNSAFE - crashes if not array
$json.items.map(i => i.name)

// ✅ SAFE
($json?.items || []).map(i => i?.name || 'unknown')

// ✅ SAFE - with length check
($json?.items || []).length > 0 ? $json.items[0] : null
```

---

## Testing Scenarios

### Scenario 1: Null Propagation Test

**Input:**
```json
{
  "json": null
}
```

**Expected Behavior:**
- All expressions should return fallback values
- No workflow crashes
- Error Handler activated
- Client receives error email

### Scenario 2: Empty Object Test

**Input:**
```json
{
  "json": {}
}
```

**Expected Behavior:**
- All optional chaining returns undefined → fallbacks used
- Validation catches missing required fields
- Error Handler activated

### Scenario 3: Malicious Input Test

**Input:**
```json
{
  "clientBrief": "<script>alert('XSS')</script>",
  "clientEmail": "'; DROP TABLE users; --"
}
```

**Expected Behavior:**
- HTML in brief is fully escaped
- Email validation fails → uses fallback email
- No code execution
- Sanitized content in delivered email

### Scenario 4: API Failure Cascade

**Simulation:** Remove `GEMINI_API_KEY` from environment

**Expected Behavior:**
- All Gemini API calls fail with 401
- `continueOnFail: true` prevents crash
- Error Handler catches failures
- Client receives clear error message

### Scenario 5: Partial Data Test

**Input:**
```json
{
  "clientBrief": "Create workflow",
  "clientEmail": null
}
```

**Expected Behavior:**
- Brief processes normally
- Email validation fails → uses fallback
- Workflow generated but sent to fallback address
- Consider logging this scenario

---

## Troubleshooting

### Issue: Expressions Returning "[object Object]"

**Cause:** Trying to concatenate object directly into string

**Solution:**
```javascript
// ❌ WRONG
'Data: ' + $json.object

// ✅ RIGHT
'Data: ' + JSON.stringify($json?.object || {})
```

### Issue: Conditional Not Working as Expected

**Cause:** Using `||` when you need `??`

**Solution:**
```javascript
// ❌ WRONG - treats 0, false, '' as "use fallback"
$json.value || 'default'

// ✅ RIGHT - only null/undefined trigger fallback
$json.value ?? 'default'
```

### Issue: Email Not Sending

**Cause:** Invalid email address format

**Debug:**
1. Check if email passes regex: `/^[^\s@]+@[^\s@]+\.[^\s@]+$/`
2. Verify fallback email is valid
3. Check Gmail OAuth2 credentials
4. Review n8n execution logs

**Solution:** Use email validation pattern from Pattern 4

### Issue: XSS Still Possible

**Cause:** Escaping applied to wrong content or missing escape

**Audit:**
1. Find all HTML message parameters
2. Verify escape function is applied
3. Check that trusted HTML sources are actually safe
4. Test with XSS payloads from OWASP list

### Issue: Workflow Crashes Despite Null Checks

**Cause:** Expression evaluated before null check

**Debug:**
```javascript
// ❌ WRONG - property accessed before check
$json.property || 'fallback'  // crashes if $json is null

// ✅ RIGHT - optional chaining prevents access attempt
$json?.property || 'fallback'
```

---

## Best Practices

### 1. Always Use Optional Chaining

```javascript
// Default to this pattern for ALL property access
$json?.property?.nestedProperty || 'fallback'
```

### 2. Validate All User Input

```javascript
// Email, URLs, file paths, etc.
const validated = validateFunction(userInput) ? userInput : fallback;
```

### 3. Escape All HTML Output

```javascript
// If it came from user, it gets escaped
const safe = escapeHtml(userContent);
```

### 4. Provide Meaningful Fallbacks

```javascript
// ❌ BAD - unclear what went wrong
|| ''

// ✅ GOOD - helps debugging
|| 'No brief provided'
|| {error: 'Missing data', stage: 'architect'}
```

### 5. Use Type Guards

```javascript
// Check types before operations
typeof $json.value === 'number' ? $json.value : 0
Array.isArray($json.items) ? $json.items : []
```

### 6. Document Complex Expressions

```javascript
// In Code nodes, add comments explaining logic
// For inline expressions, document in this file

// Example: Line 276 uses IIFE for HTML escaping because...
```

### 7. Test Edge Cases Before Deploying

- Run workflow with null data
- Test with malicious input
- Verify all fallbacks work
- Check error handling paths

### 8. Monitor Production

- Set up alerts for expression errors
- Log fallback usage
- Track API failures
- Review sanitized outputs

### 9. Keep Security Updated

- Review OWASP XSS prevention regularly
- Update email regex if standards change
- Audit new n8n expression features
- Test against new attack vectors

### 10. Version Control

- Document all expression changes
- Test before deploying updates
- Keep this document current
- Review during code reviews

---

## Summary

This workflow now handles **ALL** critical and warning-level edge cases:

✅ **Critical Issues Fixed:**
1. Unsafe nested path access → Optional chaining with fallbacks
2. XSS vulnerability → HTML escaping function
3. Syntax inconsistency → Proper `={{...}}` syntax

✅ **Warning Issues Fixed:**
1. Null checks → Optional chaining throughout
2. Email validation → Regex validation with fallback
3. Environment variables → Fallback values
4. Data fallbacks → Descriptive fallback messages
5. HTML safety → Escape functions for all user content

✅ **Production Ready:**
- All expressions tested
- Edge cases documented
- Security audited
- Test suite created

---

## Maintenance

**Review Schedule:**
- Monthly: Check for new n8n expression features
- Quarterly: Security audit against OWASP updates
- Per deployment: Run full test suite
- After incidents: Document new edge cases

**Contact:**
- Workflow Owner: n8n Workflow Team
- Security Contact: security@example.com
- Documentation: This file

**Version History:**
- v1.0 (2025-11-17): Initial edge case documentation
- All 15 expression locations documented and secured

---

**Document Status:** ✅ Complete and Production-Ready
