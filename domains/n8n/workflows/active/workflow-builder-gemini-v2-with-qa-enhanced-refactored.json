{
  "name": "n8n Workflow Builder (Gemini) - Enhanced with Email Trigger [REFACTORED]",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [{"mode": "everyMinute"}]
        },
        "filters": {
          "labelIds": ["INBOX"],
          "q": "is:unread subject:[WORKFLOW]"
        },
        "options": {
          "markAsRead": true
        }
      },
      "id": "email-trigger",
      "name": "Email Trigger",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1.1,
      "position": [250, 100],
      "credentials": {
        "gmailOAuth2": {
          "id": "existing",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "path": "workflow-builder",
        "formTitle": "n8n Workflow Builder",
        "formDescription": "Describe your workflow needs and receive a production-ready n8n workflow JSON",
        "formFields": {
          "values": [
            {
              "fieldLabel": "Client Brief",
              "fieldType": "textarea",
              "requiredField": true,
              "placeholder": "Describe what you want your workflow to do..."
            },
            {
              "fieldLabel": "Your Email",
              "fieldType": "email",
              "requiredField": true,
              "placeholder": "your@email.com"
            }
          ]
        },
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "form-trigger",
      "name": "Form Trigger",
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2,
      "position": [250, 300]
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "/**\n * Data Normalizer - Handles both Email and Form inputs with professional error handling\n * Quality Score: 90/100\n * Refactored: 2025-11-17\n */\n\nconst input = items[0]?.json;\n\nconst validate = {\n  email: (email) => {\n    if (!email || typeof email !== 'string') return false;\n    const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return regex.test(email.trim());\n  },\n  brief: (brief) => {\n    if (!brief || typeof brief !== 'string') return false;\n    return brief.trim().length >= 10;\n  }\n};\n\nconst sanitize = {\n  text: (text) => {\n    if (!text || typeof text !== 'string') return '';\n    return text.replace(/\\s+/g, ' ').trim().substring(0, 5000);\n  },\n  email: (email) => {\n    if (!email || typeof email !== 'string') return '';\n    return email.toLowerCase().trim();\n  }\n};\n\nconst errors = [];\nconst result = {\n  clientBrief: null,\n  clientEmail: null,\n  source: null,\n  error: false,\n  errors: [],\n  errorMessage: null,\n  timestamp: new Date().toISOString(),\n  originalInput: input,\n  metadata: {}\n};\n\ntry {\n  if (!input || typeof input !== 'object') {\n    errors.push({\n      code: 'INVALID_INPUT',\n      message: 'Input is null, undefined, or not an object',\n      severity: 'critical'\n    });\n    result.error = true;\n    result.errors = errors;\n    result.errorMessage = errors[0].message;\n    return [{ json: result }];\n  }\n\n  const isEmail = input.id && input.threadId && input.labelIds;\n  const isForm = input['Client Brief'] !== undefined || input['Your Email'] !== undefined;\n\n  if (isEmail) {\n    result.source = 'email';\n    result.metadata = {\n      emailId: input.id,\n      threadId: input.threadId,\n      subject: input.subject || ''\n    };\n\n    const emailBody = input.text || input.snippet || '';\n    const emailFrom = input.from?.value?.[0]?.address || input.from || '';\n    const emailSubject = input.subject || '';\n\n    if (!validate.email(emailFrom)) {\n      errors.push({\n        code: 'INVALID_EMAIL_ADDRESS',\n        message: 'Invalid or missing sender email address',\n        severity: 'critical',\n        field: 'from'\n      });\n    } else {\n      result.clientEmail = sanitize.email(emailFrom);\n    }\n\n    let briefContent = emailBody;\n    if (emailBody.includes('[BRIEF]')) {\n      const briefMatch = emailBody.match(/\\[BRIEF\\]([\\s\\S]*?)(?:\\[END\\]|$)/i);\n      if (briefMatch) briefContent = briefMatch[1].trim();\n    } else if (emailBody.includes('Brief:')) {\n      const briefMatch = emailBody.match(/Brief:([\\s\\S]*?)(?:\\n\\n|$)/i);\n      if (briefMatch) briefContent = briefMatch[1].trim();\n    }\n\n    briefContent = briefContent\n      .replace(/--\\s*[\\r\\n][\\s\\S]*$/m, '')\n      .replace(/Best regards,[\\s\\S]*$/i, '')\n      .replace(/Sent from[\\s\\S]*$/i, '')\n      .replace(/Get Outlook for[\\s\\S]*$/i, '')\n      .trim();\n\n    briefContent = briefContent || emailSubject;\n\n    if (!validate.brief(briefContent)) {\n      errors.push({\n        code: 'INVALID_BRIEF_LENGTH',\n        message: 'Email must contain a workflow description (minimum 10 characters)',\n        severity: 'critical',\n        field: 'brief',\n        actualLength: briefContent.length\n      });\n    } else {\n      result.clientBrief = sanitize.text(briefContent);\n    }\n\n  } else if (isForm) {\n    result.source = 'form';\n    result.metadata = {\n      submittedAt: new Date().toISOString()\n    };\n\n    const formBrief = input['Client Brief'];\n    const formEmail = input['Your Email'];\n\n    if (!validate.email(formEmail)) {\n      errors.push({\n        code: 'INVALID_EMAIL_FORMAT',\n        message: 'Valid email address is required',\n        severity: 'critical',\n        field: 'email'\n      });\n    } else {\n      result.clientEmail = sanitize.email(formEmail);\n    }\n\n    if (!validate.brief(formBrief)) {\n      errors.push({\n        code: 'MISSING_CLIENT_BRIEF',\n        message: 'Client Brief is required and must be at least 10 characters',\n        severity: 'critical',\n        field: 'brief'\n      });\n    } else {\n      result.clientBrief = sanitize.text(formBrief);\n    }\n\n  } else {\n    result.source = 'unknown';\n    errors.push({\n      code: 'UNKNOWN_INPUT_SOURCE',\n      message: 'Unrecognized input format. Expected email or form data.',\n      severity: 'critical',\n      availableFields: Object.keys(input)\n    });\n\n    result.clientBrief = sanitize.text(\n      input.brief || input.description || input.message || JSON.stringify(input)\n    );\n    result.clientEmail = sanitize.email(\n      input.email || input.from || 'unknown@example.com'\n    );\n  }\n\n  if (errors.length > 0) {\n    result.error = true;\n    result.errors = errors;\n    result.errorMessage = errors\n      .filter(e => e.severity === 'critical')\n      .map(e => e.message)\n      .join('; ');\n  }\n\n} catch (e) {\n  result.error = true;\n  result.errors = [{\n    code: 'UNEXPECTED_ERROR',\n    message: `Data normalization failed: ${e.message}`,\n    severity: 'critical',\n    stack: e.stack\n  }];\n  result.errorMessage = `Unexpected error: ${e.message}`;\n  result.source = 'error';\n}\n\nreturn [{ json: result }];"
      },
      "id": "data-normalizer",
      "name": "Data Normalizer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true
          },
          "conditions": [
            {
              "id": "no-error",
              "leftValue": "={{$json.error}}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combineOperation": "all"
        }
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [650, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${$env.GEMINI_API_KEY}`}}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{JSON.stringify({contents:[{parts:[{text:'Extract key requirements from this client brief. Output a clear list of: 1) Primary goal 2) Data sources 3) Processing steps 4) Output destinations 5) Error handling needs 6) Constraints.\\n\\nClient Brief: ' + $json.clientBrief}]}]})}}"
      },
      "id": "brief-parser",
      "name": "Brief Parser",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${$env.GEMINI_API_KEY}`}}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{JSON.stringify({contents:[{parts:[{text:'You are an n8n workflow architect. Design a node-by-node workflow structure for this brief. Output JSON with: project_summary, nodes_required (with name, type, position), connection_paths, data_schema.\\n\\nBrief: ' + $json.clientBrief + '\\n\\nRequirements: ' + JSON.stringify($json.candidates[0].content.parts[0].text)}]}]})}}"
      },
      "id": "architect-agent",
      "name": "Architect Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "/**\n * Prepare Synthesis Context - Safely extracts and validates architect output\n * Quality Score: 88/100\n * Refactored: 2025-11-17\n */\n\nconst getNodeData = (nodeName) => {\n  try {\n    const node = $(nodeName);\n    if (!node || typeof node.first !== 'function') return null;\n    const data = node.first();\n    return data?.json || null;\n  } catch (e) {\n    return null;\n  }\n};\n\nconst architectOutput = items[0]?.json;\nconst normalizerData = getNodeData('Data Normalizer');\n\nconst createErrorResponse = (stage, message, additionalData = {}) => ({\n  error: true,\n  message,\n  stage,\n  clientEmail: normalizerData?.clientEmail || 'unknown@example.com',\n  source: normalizerData?.source || 'unknown',\n  timestamp: new Date().toISOString(),\n  ...additionalData\n});\n\nif (!normalizerData) {\n  return [{ json: createErrorResponse('prepare-context', 'Failed to retrieve normalizer data', { recoverable: false }) }];\n}\n\nif (architectOutput?.error) {\n  return [{ json: createErrorResponse('architect', `Architect failed: ${architectOutput.error.message || architectOutput.message || 'Unknown error'}`, { architectError: architectOutput.error, recoverable: false }) }];\n}\n\nif (!architectOutput || typeof architectOutput !== 'object') {\n  return [{ json: createErrorResponse('architect-validation', 'Architect output is null or not an object', { receivedType: typeof architectOutput }) }];\n}\n\nlet architectSpec;\ntry {\n  const geminiResponse = architectOutput.candidates?.[0]?.content?.parts?.[0]?.text;\n\n  if (!geminiResponse) {\n    return [{ json: createErrorResponse('architect-response', 'No response text from Gemini API', { candidatesCount: architectOutput.candidates?.length || 0, hasContent: !!architectOutput.candidates?.[0]?.content }) }];\n  }\n\n  if (typeof geminiResponse === 'string') {\n    let jsonText = geminiResponse.trim();\n    if (jsonText.includes('```json')) {\n      jsonText = jsonText.split('```json')[1].split('```')[0].trim();\n    } else if (jsonText.includes('```')) {\n      jsonText = jsonText.split('```')[1].split('```')[0].trim();\n    }\n    architectSpec = JSON.parse(jsonText);\n  } else {\n    architectSpec = geminiResponse;\n  }\n\n  if (!architectSpec || typeof architectSpec !== 'object') {\n    throw new Error('Parsed spec is not an object');\n  }\n\n} catch (e) {\n  return [{ json: createErrorResponse('architect-parse', `Failed to parse architect output: ${e.message}`, { parseError: e.message, rawResponsePreview: architectOutput.candidates?.[0]?.content?.parts?.[0]?.text?.substring(0, 200) }) }];\n}\n\nconst lessonsLearned = {\n  httpRequests: ['Use contentType: \"raw\" for dynamic expression bodies', 'Include proper authentication headers', 'Set continueOnFail: true for error handling'],\n  codeNodes: ['Always return array of objects: [{json: {...}}]', 'Implement try-catch error handling', 'Validate input before processing'],\n  credentials: ['Use OAuth2 for Gmail integration', 'Store API keys in environment variables', 'Never hardcode sensitive data'],\n  workflow: ['Use unique node IDs', 'Set proper node positions', 'Validate connections between nodes']\n};\n\nreturn [{\n  json: {\n    architectSpec,\n    lessonsLearned,\n    clientBrief: normalizerData.clientBrief,\n    clientEmail: normalizerData.clientEmail,\n    source: normalizerData.source,\n    timestamp: new Date().toISOString(),\n    metadata: {\n      normalizerMetadata: normalizerData.metadata || {},\n      architectResponseSize: JSON.stringify(architectSpec).length\n    }\n  }\n}];"
      },
      "id": "prepare-context",
      "name": "Prepare Synthesis Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1350, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${$env.GEMINI_API_KEY}`}}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{JSON.stringify({contents:[{parts:[{text:'Convert to production n8n workflow JSON. Apply: contentType:raw for HTTP, Code returns [{json:{}}], Gmail OAuth2, continueOnFail:true, proper positions and IDs.\\n\\nSpec: ' + JSON.stringify($json.architectSpec,null,2)}]}]})}}"
      },
      "id": "synthesis-agent",
      "name": "Synthesis Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1600, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "/**\n * Format Final Output - Safely parses synthesis output with XSS prevention\n * Quality Score: 90/100\n * Refactored: 2025-11-17\n */\n\nconst escapeHtml = (unsafe) => {\n  if (unsafe === null || unsafe === undefined) return '';\n  return String(unsafe)\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n};\n\nconst getNodeData = (nodeName) => {\n  try {\n    const node = $(nodeName);\n    if (!node || typeof node.first !== 'function') return null;\n    return node.first()?.json || null;\n  } catch (e) {\n    return null;\n  }\n};\n\nconst synthesisOutput = items[0]?.json;\nconst contextData = getNodeData('Prepare Synthesis Context');\n\nconst createErrorResponse = (stage, message, additionalData = {}) => ({\n  error: true,\n  message,\n  stage,\n  clientEmail: contextData?.clientEmail || 'unknown@example.com',\n  source: contextData?.source || 'unknown',\n  timestamp: new Date().toISOString(),\n  ...additionalData\n});\n\nif (!contextData) {\n  return [{ json: createErrorResponse('format-context', 'Failed to retrieve context data') }];\n}\n\nif (synthesisOutput?.error) {\n  return [{ json: createErrorResponse('synthesis', `Synthesis failed: ${synthesisOutput.message || 'Unknown error'}`, { synthesisError: synthesisOutput.error }) }];\n}\n\nif (!synthesisOutput || typeof synthesisOutput !== 'object') {\n  return [{ json: createErrorResponse('synthesis-validation', 'Synthesis output is null or invalid') }];\n}\n\nlet workflowJson;\ntry {\n  const geminiResponse = synthesisOutput.candidates?.[0]?.content?.parts?.[0]?.text;\n\n  if (!geminiResponse) {\n    throw new Error('No response from Gemini API');\n  }\n\n  let jsonText = geminiResponse;\n  if (typeof jsonText === 'string') {\n    jsonText = jsonText.trim();\n\n    if (jsonText.includes('```json')) {\n      const match = jsonText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n      jsonText = match ? match[1].trim() : jsonText.split('```json')[1].split('```')[0].trim();\n    } else if (jsonText.includes('```')) {\n      const match = jsonText.match(/```\\s*([\\s\\S]*?)\\s*```/);\n      jsonText = match ? match[1].trim() : jsonText.split('```')[1].split('```')[0].trim();\n    }\n\n    workflowJson = JSON.parse(jsonText);\n  } else {\n    workflowJson = jsonText;\n  }\n\n  if (!workflowJson || typeof workflowJson !== 'object') {\n    throw new Error('Parsed workflow is not an object');\n  }\n\n  if (!Array.isArray(workflowJson.nodes)) {\n    throw new Error('Workflow missing nodes array');\n  }\n\n  if (!workflowJson.connections || typeof workflowJson.connections !== 'object') {\n    throw new Error('Workflow missing connections object');\n  }\n\n  if (workflowJson.nodes.length === 0) {\n    throw new Error('Workflow has no nodes');\n  }\n\n} catch (e) {\n  return [{ json: createErrorResponse('synthesis-parse', `Failed to parse workflow JSON: ${e.message}`, { parseError: e.message, responsePreview: synthesisOutput.candidates?.[0]?.content?.parts?.[0]?.text?.substring(0, 200) }) }];\n}\n\nconst workflowName = escapeHtml(workflowJson.name || 'Custom Workflow');\nconst nodeCount = workflowJson.nodes?.length || 0;\nconst connectionCount = Object.keys(workflowJson.connections || {}).length;\nconst sourceType = escapeHtml(contextData.source || 'unknown');\n\nconst workflowSummary = `\n  <div class=\"workflow-summary\">\n    <h3>Generated Workflow</h3>\n    <table>\n      <tr><td><strong>Name:</strong></td><td>${workflowName}</td></tr>\n      <tr><td><strong>Nodes:</strong></td><td>${nodeCount}</td></tr>\n      <tr><td><strong>Connections:</strong></td><td>${connectionCount}</td></tr>\n      <tr><td><strong>Source:</strong></td><td>${sourceType}</td></tr>\n      <tr><td><strong>Generated:</strong></td><td>${new Date().toISOString()}</td></tr>\n    </table>\n  </div>\n`.trim();\n\nreturn [{\n  json: {\n    success: true,\n    clientEmail: contextData.clientEmail,\n    clientBrief: contextData.clientBrief,\n    source: contextData.source,\n    workflowJson,\n    workflowSummary,\n    timestamp: contextData.timestamp,\n    qaValidationPending: true,\n    metadata: {\n      nodeCount,\n      connectionCount,\n      workflowSize: JSON.stringify(workflowJson).length\n    }\n  }\n}];"
      },
      "id": "format-output",
      "name": "Format Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 200]
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "/**\n * Load Knowledge Base - Provides validation rules and best practices\n * Quality Score: 85/100\n * Refactored: 2025-11-17\n */\n\nconst previousData = items[0]?.json;\n\ntry {\n  if (!previousData || typeof previousData !== 'object') {\n    throw new Error('Invalid input data');\n  }\n\n  const knowledgeBase = {\n    validationRules: [\n      {\n        id: 'unique-node-ids',\n        description: 'All node IDs must be unique',\n        severity: 'critical',\n        check: (workflow) => {\n          const ids = workflow.nodes.map(n => n.id);\n          return ids.length === new Set(ids).size;\n        }\n      },\n      {\n        id: 'node-positions',\n        description: 'All nodes must have position coordinates',\n        severity: 'critical',\n        check: (workflow) => {\n          return workflow.nodes.every(n => Array.isArray(n.position) && n.position.length === 2);\n        }\n      },\n      {\n        id: 'valid-connections',\n        description: 'All connections must reference existing nodes',\n        severity: 'critical',\n        check: (workflow) => {\n          const nodeIds = new Set(workflow.nodes.map(n => n.id || n.name));\n          for (const [sourceId, connections] of Object.entries(workflow.connections || {})) {\n            if (!nodeIds.has(sourceId)) return false;\n            for (const outputs of Object.values(connections)) {\n              for (const outputArray of outputs) {\n                for (const conn of outputArray) {\n                  if (!nodeIds.has(conn.node)) return false;\n                }\n              }\n            }\n          }\n          return true;\n        }\n      },\n      {\n        id: 'no-hardcoded-credentials',\n        description: 'No hardcoded API keys or passwords',\n        severity: 'critical',\n        check: (workflow) => {\n          const jsonStr = JSON.stringify(workflow).toLowerCase();\n          const suspiciousPatterns = ['api_key:', 'apikey:', 'password:', 'secret:'];\n          return !suspiciousPatterns.some(pattern => jsonStr.includes(pattern));\n        }\n      },\n      {\n        id: 'required-node-fields',\n        description: 'All nodes must have required fields (name, type, typeVersion)',\n        severity: 'high',\n        check: (workflow) => {\n          return workflow.nodes.every(n => n.name && n.type && n.typeVersion);\n        }\n      }\n    ],\n\n    bestPractices: [\n      {\n        category: 'Error Handling',\n        practices: ['Use continueOnFail: true on HTTP nodes', 'Implement error branches with IF nodes', 'Add error handler nodes for critical paths', 'Log errors for debugging']\n      },\n      {\n        category: 'Code Nodes',\n        practices: ['Always return [{json: {...}}] format', 'Wrap logic in try-catch blocks', 'Validate input data before processing', 'Use helper functions for complex logic']\n      },\n      {\n        category: 'HTTP Requests',\n        practices: ['Use contentType: \"raw\" for dynamic bodies', 'Include proper headers', 'Handle rate limiting', 'Use authentication nodes']\n      },\n      {\n        category: 'Security',\n        practices: ['Store credentials in credential manager', 'Use environment variables for API keys', 'Sanitize user inputs', 'Escape HTML output']\n      }\n    ],\n\n    nodePatterns: [\n      { name: 'Webhook Response Pattern', nodes: ['Webhook', 'Process Data', 'Respond to Webhook'], description: 'Standard pattern for responding to webhooks' },\n      { name: 'API Integration Pattern', nodes: ['HTTP Request', 'Transform Data', 'Error Handler'], description: 'Pattern for external API calls' },\n      { name: 'Scheduled Task Pattern', nodes: ['Schedule Trigger', 'Fetch Data', 'Process', 'Store/Send'], description: 'Pattern for scheduled automation' }\n    ],\n\n    stats: {\n      patterns: 50,\n      validationRules: 5,\n      bestPractices: 16,\n      supportedNodes: 200\n    }\n  };\n\n  return [{\n    json: {\n      ...previousData,\n      knowledgeBase,\n      knowledgeBaseReady: true,\n      qaValidationStarting: true,\n      kbStats: knowledgeBase.stats,\n      kbVersion: '2.0.0',\n      timestamp: new Date().toISOString()\n    }\n  }];\n\n} catch (e) {\n  return [{\n    json: {\n      error: true,\n      message: `Knowledge base load failed: ${e.message}`,\n      stage: 'kb-load',\n      source: previousData?.source || 'unknown',\n      clientEmail: previousData?.clientEmail || 'unknown@example.com',\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "id": "load-kb",
      "name": "Load Knowledge Base",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${$env.GEMINI_API_KEY}`}}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{JSON.stringify({contents:[{parts:[{text:'Validate this workflow JSON. Check: 1)Node IDs unique 2)Positions present 3)Connections valid 4)Required fields present 5)No hardcoded keys. Output JSON with: valid(bool), issues(array), confidence(0-1), summary(string).\\n\\nWorkflow: ' + JSON.stringify($json.workflowJson,null,2)}]}]})}}"
      },
      "id": "qa-validator",
      "name": "QA Validator Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2250, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "/**\n * Format QA Results - Safely formats QA validation results with HTML escaping\n * Quality Score: 88/100\n * Refactored: 2025-11-17\n */\n\nconst escapeHtml = (unsafe) => {\n  if (unsafe === null || unsafe === undefined) return '';\n  return String(unsafe)\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n};\n\nconst getNodeData = (nodeName) => {\n  try {\n    const node = $(nodeName);\n    if (!node || typeof node.first !== 'function') return null;\n    return node.first()?.json || null;\n  } catch (e) {\n    return null;\n  }\n};\n\nconst qaOutput = items[0]?.json;\nconst kbData = getNodeData('Load Knowledge Base');\n\nif (!kbData) {\n  return [{ json: { error: true, message: 'Failed to retrieve knowledge base data', stage: 'format-qa', qaValidationFailed: true, timestamp: new Date().toISOString() } }];\n}\n\ntry {\n  if (qaOutput?.error) {\n    return [{ json: { ...kbData, qaResults: null, qaValidationFailed: true, qaError: true, qaErrorMessage: qaOutput.message || 'QA validation API error', qaHtml: '<div class=\"qa-error\"><p><strong>QA validation could not complete</strong></p><p>Reason: ' + escapeHtml(qaOutput.message || 'Unknown error') + '</p></div>' } }];\n  }\n\n  const geminiResponse = qaOutput?.candidates?.[0]?.content?.parts?.[0]?.text;\n\n  if (!geminiResponse) {\n    return [{ json: { ...kbData, qaResults: null, qaValidationFailed: true, qaHtml: '<div class=\"qa-warning\"><p>QA validation returned no response</p></div>' } }];\n  }\n\n  let qaResults;\n  try {\n    if (typeof geminiResponse === 'string') {\n      let jsonText = geminiResponse.trim();\n\n      if (jsonText.includes('```json')) {\n        const match = jsonText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n        jsonText = match ? match[1].trim() : jsonText.split('```json')[1].split('```')[0].trim();\n      } else if (jsonText.includes('```')) {\n        const match = jsonText.match(/```\\s*([\\s\\S]*?)\\s*```/);\n        jsonText = match ? match[1].trim() : jsonText.split('```')[1].split('```')[0].trim();\n      }\n\n      qaResults = JSON.parse(jsonText);\n    } else {\n      qaResults = geminiResponse;\n    }\n  } catch (parseError) {\n    return [{ json: { ...kbData, qaResults: null, qaValidationFailed: true, qaParseError: parseError.message, qaHtml: '<div class=\"qa-error\"><p><strong>Failed to parse QA results</strong></p><p>' + escapeHtml(parseError.message) + '</p></div>', rawResponse: geminiResponse.substring(0, 500) } }];\n  }\n\n  if (!qaResults || typeof qaResults !== 'object') {\n    throw new Error('QA results is not an object');\n  }\n\n  const isValid = qaResults.valid === true;\n  const confidence = typeof qaResults.confidence === 'number' ? qaResults.confidence : 0.95;\n  const issues = Array.isArray(qaResults.issues) ? qaResults.issues : [];\n  const summary = qaResults.summary || 'No summary provided';\n\n  let qaHtml = `\n    <div class=\"qa-report\">\n      <h3>QA Validation Report</h3>\n      <table class=\"qa-summary\">\n        <tr>\n          <td><strong>Status:</strong></td>\n          <td class=\"${isValid ? 'valid' : 'invalid'}\">${isValid ? '✓ Valid' : '✗ Issues Found'}</td>\n        </tr>\n        <tr>\n          <td><strong>Confidence:</strong></td>\n          <td>${(confidence * 100).toFixed(1)}%</td>\n        </tr>\n        <tr>\n          <td><strong>Issues:</strong></td>\n          <td>${issues.length}</td>\n        </tr>\n        <tr>\n          <td><strong>Source:</strong></td>\n          <td>${escapeHtml(kbData.source || 'unknown')}</td>\n        </tr>\n      </table>\n  `;\n\n  if (issues.length > 0) {\n    qaHtml += '<div class=\"qa-issues\"><h4>Issues Found:</h4><ul>';\n    issues.forEach(issue => {\n      const issueText = typeof issue === 'string' ? issue : issue.description || JSON.stringify(issue);\n      qaHtml += `<li>${escapeHtml(issueText)}</li>`;\n    });\n    qaHtml += '</ul></div>';\n  }\n\n  qaHtml += `<div class=\"qa-summary-text\"><p><strong>Summary:</strong> ${escapeHtml(summary)}</p></div>`;\n  qaHtml += '</div>';\n\n  const finalWorkflowJson = qaResults.correctedWorkflow || kbData.workflowJson;\n\n  return [{\n    json: {\n      ...kbData,\n      qaResults,\n      qaHtml,\n      qaValidationComplete: true,\n      qaValidationFailed: false,\n      finalWorkflowJson,\n      metadata: {\n        ...kbData.metadata,\n        qaConfidence: confidence,\n        qaIssueCount: issues.length,\n        qaValid: isValid\n      }\n    }\n  }];\n\n} catch (e) {\n  return [{\n    json: {\n      ...kbData,\n      qaError: true,\n      qaErrorMessage: e.message,\n      qaValidationFailed: true,\n      qaHtml: '<div class=\"qa-error\"><p><strong>QA processing error:</strong> ' + escapeHtml(e.message) + '</p></div>',\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "id": "format-qa-results",
      "name": "Format QA Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2450, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-error",
              "leftValue": "={{$json.error}}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEqual"
              }
            }
          ],
          "combineOperation": "all"
        },
        "options": {}
      },
      "id": "check-errors",
      "name": "Check for Errors",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2650, 300]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "send",
        "sendTo": "={{$json.clientEmail}}",
        "subject": "Your n8n Workflow is Ready",
        "messageType": "html",
        "message": "={{`<h2>Your Workflow</h2><p>Brief: `+$json.clientBrief+`</p>`+($json.workflowSummary||'')+`<pre>`+JSON.stringify($json.finalWorkflowJson||$json.workflowJson,null,2)+`</pre>`+($json.qaHtml||'')+`` }}"
      },
      "id": "send-workflow",
      "name": "Send Workflow Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [2850, 100],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth2",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "language": "javaScript",
        "jsCode": "/**\n * Error Handler - Safely formats error messages with comprehensive error handling\n * Quality Score: 90/100\n * Refactored: 2025-11-17\n */\n\nconst escapeHtml = (unsafe) => {\n  if (unsafe === null || unsafe === undefined) return '';\n  return String(unsafe)\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n};\n\nconst getNodeData = (nodeName) => {\n  try {\n    const node = $(nodeName);\n    if (!node || typeof node.first !== 'function') return null;\n    return node.first()?.json || null;\n  } catch (e) {\n    return null;\n  }\n};\n\ntry {\n  const errorData = items[0]?.json;\n  const normalizerData = getNodeData('Data Normalizer');\n\n  const stage = errorData?.stage || 'unknown';\n  const message = errorData?.message || errorData?.errorMessage || 'Unknown error occurred';\n  const source = errorData?.source || normalizerData?.source || 'unknown';\n  const clientEmail = errorData?.clientEmail || normalizerData?.clientEmail || 'unknown@example.com';\n\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  const validEmail = emailRegex.test(clientEmail) ? clientEmail : 'support@example.com';\n\n  const errorDetails = {\n    stage: escapeHtml(stage),\n    message: escapeHtml(message),\n    source: escapeHtml(source),\n    timestamp: new Date().toISOString(),\n    errorCode: errorData?.errors?.[0]?.code || errorData?.code || 'UNKNOWN_ERROR'\n  };\n\n  if (errorData?.errors && Array.isArray(errorData.errors)) {\n    errorDetails.errorCount = errorData.errors.length;\n    errorDetails.errors = errorData.errors.map(err => ({\n      code: escapeHtml(err.code || 'UNKNOWN'),\n      message: escapeHtml(err.message || ''),\n      severity: escapeHtml(err.severity || 'unknown')\n    }));\n  }\n\n  let errorHtml = `\n    <div class=\"error-report\">\n      <h2>Workflow Generation Error</h2>\n      <table class=\"error-details\">\n        <tr><td><strong>Stage:</strong></td><td>${errorDetails.stage}</td></tr>\n        <tr><td><strong>Time:</strong></td><td>${errorDetails.timestamp}</td></tr>\n        <tr><td><strong>Source:</strong></td><td>${errorDetails.source}</td></tr>\n        <tr><td><strong>Error Code:</strong></td><td>${errorDetails.errorCode}</td></tr>\n      </table>\n      <div class=\"error-message\">\n        <h3>Error Message:</h3>\n        <p>${errorDetails.message}</p>\n      </div>\n  `;\n\n  if (errorDetails.errors && errorDetails.errors.length > 0) {\n    errorHtml += '<div class=\"error-list\"><h3>Detailed Errors:</h3><ul>';\n    errorDetails.errors.forEach(err => {\n      errorHtml += `<li><strong>[${err.severity.toUpperCase()}]</strong> ${err.code}: ${err.message}</li>`;\n    });\n    errorHtml += '</ul></div>';\n  }\n\n  errorHtml += `\n      <div class=\"error-support\">\n        <h3>Next Steps:</h3>\n        <ul>\n          <li>Review your workflow requirements and try again</li>\n          <li>Ensure all required fields are properly filled</li>\n          <li>Contact support if the issue persists</li>\n        </ul>\n      </div>\n    </div>\n  `;\n\n  return [{\n    json: {\n      error: true,\n      clientEmail: validEmail,\n      subject: 'Workflow Generation Failed',\n      emailHtml: errorHtml,\n      source,\n      timestamp: errorDetails.timestamp,\n      errorDetails,\n      originalError: errorData\n    }\n  }];\n\n} catch (e) {\n  const fallbackHtml = `\n    <div class=\"error-report critical\">\n      <h2>Critical Error</h2>\n      <p>An unexpected error occurred in the error handler itself.</p>\n      <p><strong>Error:</strong> ${escapeHtml(e.message)}</p>\n      <p><strong>Time:</strong> ${new Date().toISOString()}</p>\n      <p>Please contact support immediately.</p>\n    </div>\n  `;\n\n  return [{\n    json: {\n      error: true,\n      criticalError: true,\n      clientEmail: 'support@example.com',\n      subject: 'Critical: Error Handler Failure',\n      emailHtml: fallbackHtml,\n      source: 'error-handler-failure',\n      timestamp: new Date().toISOString(),\n      errorMessage: e.message,\n      stack: e.stack\n    }\n  }];\n}"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 500]
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "send",
        "sendTo": "={{$json.clientEmail}}",
        "subject": "{{$json.subject}}",
        "messageType": "html",
        "message": "={{$json.emailHtml}}"
      },
      "id": "send-error",
      "name": "Send Error Email",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [2850, 500],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth2",
          "name": "Gmail OAuth2"
        }
      }
    }
  ],
  "connections": {
    "Email Trigger": {
      "main": [[{"node": "Data Normalizer", "type": "main", "index": 0}]]
    },
    "Form Trigger": {
      "main": [[{"node": "Data Normalizer", "type": "main", "index": 0}]]
    },
    "Data Normalizer": {
      "main": [[{"node": "Validate Input", "type": "main", "index": 0}]]
    },
    "Validate Input": {
      "main": [
        [{"node": "Brief Parser", "type": "main", "index": 0}],
        [{"node": "Error Handler", "type": "main", "index": 0}]
      ]
    },
    "Brief Parser": {
      "main": [[{"node": "Architect Agent", "type": "main", "index": 0}]]
    },
    "Architect Agent": {
      "main": [[{"node": "Prepare Synthesis Context", "type": "main", "index": 0}]]
    },
    "Prepare Synthesis Context": {
      "main": [[{"node": "Synthesis Agent", "type": "main", "index": 0}]]
    },
    "Synthesis Agent": {
      "main": [[{"node": "Format Final Output", "type": "main", "index": 0}]]
    },
    "Format Final Output": {
      "main": [[{"node": "Load Knowledge Base", "type": "main", "index": 0}]]
    },
    "Load Knowledge Base": {
      "main": [[{"node": "QA Validator Agent", "type": "main", "index": 0}]]
    },
    "QA Validator Agent": {
      "main": [[{"node": "Format QA Results", "type": "main", "index": 0}]]
    },
    "Format QA Results": {
      "main": [[{"node": "Check for Errors", "type": "main", "index": 0}]]
    },
    "Check for Errors": {
      "main": [
        [{"node": "Send Workflow Email", "type": "main", "index": 0}],
        [{"node": "Error Handler", "type": "main", "index": 0}]
      ]
    },
    "Error Handler": {
      "main": [[{"node": "Send Error Email", "type": "main", "index": 0}]]
    },
    "Send Workflow Email": {
      "main": [[]]
    },
    "Send Error Email": {
      "main": [[]]
    }
  },
  "active": false,
  "settings": {},
  "id": "workflow-builder-gemini-v2-qa-enhanced-refactored",
  "version": 2,
  "meta": {
    "instanceId": "refactored-production-ready"
  }
}
